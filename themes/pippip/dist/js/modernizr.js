/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./.modernizrrc.js":
/*!*************************!*\
  !*** ./.modernizrrc.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n;\n\n(function (window) {\n  var hadGlobal = 'Modernizr' in window;\n  var oldGlobal = window.Modernizr;\n  /*!\n   * modernizr v3.8.0\n   * Build https://modernizr.com/download?-addtest-printshiv-setclasses-testprop-dontmin\n   *\n   * Copyright (c)\n   *  Faruk Ates\n   *  Paul Irish\n   *  Alex Sexton\n   *  Ryan Seddon\n   *  Patrick Kettner\n   *  Stu Cox\n   *  Richard Herrera\n   *  Veeck\n  \n   * MIT License\n   */\n\n  /*\n   * Modernizr tests which native CSS3 and HTML5 features are available in the\n   * current UA and makes the results available to you in two ways: as properties on\n   * a global `Modernizr` object, and as classes on the `<html>` element. This\n   * information allows you to progressively enhance your pages with a granular level\n   * of control over the experience.\n  */\n\n  ;\n\n  (function (window, document, undefined) {\n    var tests = [];\n    /**\n     * ModernizrProto is the constructor for Modernizr\n     *\n     * @class\n     * @access public\n     */\n\n    var ModernizrProto = {\n      // The current version, dummy\n      _version: '3.8.0',\n      // Any settings that don't work as separate modules\n      // can go in here as configuration.\n      _config: {\n        'classPrefix': '',\n        'enableClasses': true,\n        'enableJSClass': true,\n        'usePrefixes': true\n      },\n      // Queue of tests\n      _q: [],\n      // Stub these for people who are listening\n      on: function on(test, cb) {\n        // I don't really think people should do this, but we can\n        // safe guard it a bit.\n        // -- NOTE:: this gets WAY overridden in src/addTest for actual async tests.\n        // This is in case people listen to synchronous tests. I would leave it out,\n        // but the code to *disallow* sync tests in the real version of this\n        // function is actually larger than this.\n        var self = this;\n        setTimeout(function () {\n          cb(self[test]);\n        }, 0);\n      },\n      addTest: function addTest(name, fn, options) {\n        tests.push({\n          name: name,\n          fn: fn,\n          options: options\n        });\n      },\n      addAsyncTest: function addAsyncTest(fn) {\n        tests.push({\n          name: null,\n          fn: fn\n        });\n      }\n    }; // Fake some of Object.create so we can force non test results to be non \"own\" properties.\n\n    var Modernizr = function Modernizr() {};\n\n    Modernizr.prototype = ModernizrProto; // Leak modernizr globally when you `require` it rather than force it here.\n    // Overwrite name so constructor name is nicer :D\n\n    Modernizr = new Modernizr();\n    var classes = [];\n    /**\n     * is returns a boolean if the typeof an obj is exactly type.\n     *\n     * @access private\n     * @function is\n     * @param {*} obj - A thing we want to check the type of\n     * @param {string} type - A string to compare the typeof against\n     * @returns {boolean} true if the typeof the first parameter is exactly the specified type, false otherwise\n     */\n\n    function is(obj, type) {\n      return _typeof(obj) === type;\n    }\n\n    ;\n    /**\n     * Run through all tests and detect their support in the current UA.\n     *\n     * @access private\n     * @returns {void}\n     */\n\n    function testRunner() {\n      var featureNames;\n      var feature;\n      var aliasIdx;\n      var result;\n      var nameIdx;\n      var featureName;\n      var featureNameSplit;\n\n      for (var featureIdx in tests) {\n        if (tests.hasOwnProperty(featureIdx)) {\n          featureNames = [];\n          feature = tests[featureIdx]; // run the test, throw the return value into the Modernizr,\n          // then based on that boolean, define an appropriate className\n          // and push it into an array of classes we'll join later.\n          //\n          // If there is no name, it's an 'async' test that is run,\n          // but not directly added to the object. That should\n          // be done with a post-run addTest call.\n\n          if (feature.name) {\n            featureNames.push(feature.name.toLowerCase());\n\n            if (feature.options && feature.options.aliases && feature.options.aliases.length) {\n              // Add all the aliases into the names list\n              for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++) {\n                featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());\n              }\n            }\n          } // Run the test, or use the raw value if it's not a function\n\n\n          result = is(feature.fn, 'function') ? feature.fn() : feature.fn; // Set each of the names on the Modernizr object\n\n          for (nameIdx = 0; nameIdx < featureNames.length; nameIdx++) {\n            featureName = featureNames[nameIdx]; // Support dot properties as sub tests. We don't do checking to make sure\n            // that the implied parent tests have been added. You must call them in\n            // order (either in the test, or make the parent test a dependency).\n            //\n            // Cap it to TWO to make the logic simple and because who needs that kind of subtesting\n            // hashtag famous last words\n\n            featureNameSplit = featureName.split('.');\n\n            if (featureNameSplit.length === 1) {\n              Modernizr[featureNameSplit[0]] = result;\n            } else {\n              // cast to a Boolean, if not one already or if it doesnt exist yet (like inputtypes)\n              if (!Modernizr[featureNameSplit[0]] || Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {\n                Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);\n              }\n\n              Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result;\n            }\n\n            classes.push((result ? '' : 'no-') + featureNameSplit.join('-'));\n          }\n        }\n      }\n    }\n\n    ;\n    /**\n     * docElement is a convenience wrapper to grab the root element of the document\n     *\n     * @access private\n     * @returns {HTMLElement|SVGElement} The root element of the document\n     */\n\n    var docElement = document.documentElement;\n    /**\n     * A convenience helper to check if the document we are running in is an SVG document\n     *\n     * @access private\n     * @returns {boolean}\n     */\n\n    var isSVG = docElement.nodeName.toLowerCase() === 'svg';\n    /**\n     * setClasses takes an array of class names and adds them to the root element\n     *\n     * @access private\n     * @function setClasses\n     * @param {string[]} classes - Array of class names\n     */\n    // Pass in an and array of class names, e.g.:\n    //  ['no-webp', 'borderradius', ...]\n\n    function setClasses(classes) {\n      var className = docElement.className;\n      var classPrefix = Modernizr._config.classPrefix || '';\n\n      if (isSVG) {\n        className = className.baseVal;\n      } // Change `no-js` to `js` (independently of the `enableClasses` option)\n      // Handle classPrefix on this too\n\n\n      if (Modernizr._config.enableJSClass) {\n        var reJS = new RegExp('(^|\\\\s)' + classPrefix + 'no-js(\\\\s|$)');\n        className = className.replace(reJS, '$1' + classPrefix + 'js$2');\n      }\n\n      if (Modernizr._config.enableClasses) {\n        // Add the new classes\n        if (classes.length > 0) {\n          className += ' ' + classPrefix + classes.join(' ' + classPrefix);\n        }\n\n        if (isSVG) {\n          docElement.className.baseVal = className;\n        } else {\n          docElement.className = className;\n        }\n      }\n    }\n\n    ;\n    /**\n     * hasOwnProp is a shim for hasOwnProperty that is needed for Safari 2.0 support\n     *\n     * @author kangax\n     * @access private\n     * @function hasOwnProp\n     * @param {object} object - The object to check for a property\n     * @param {string} property - The property to check for\n     * @returns {boolean}\n     */\n    // hasOwnProperty shim by kangax needed for Safari 2.0 support\n\n    var hasOwnProp;\n\n    (function () {\n      var _hasOwnProperty = {}.hasOwnProperty;\n      /* istanbul ignore else */\n\n      /* we have no way of testing IE 5.5 or safari 2,\n       * so just assume the else gets hit */\n\n      if (!is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined')) {\n        hasOwnProp = function hasOwnProp(object, property) {\n          return _hasOwnProperty.call(object, property);\n        };\n      } else {\n        hasOwnProp = function hasOwnProp(object, property) {\n          /* yes, this can give false positives/negatives, but most of the time we don't care about those */\n          return property in object && is(object.constructor.prototype[property], 'undefined');\n        };\n      }\n    })(); // _l tracks listeners for async tests, as well as tests that execute after the initial run\n\n\n    ModernizrProto._l = {};\n    /**\n     * Modernizr.on is a way to listen for the completion of async tests. Being\n     * asynchronous, they may not finish before your scripts run. As a result you\n     * will get a possibly false negative `undefined` value.\n     *\n     * @memberOf Modernizr\n     * @name Modernizr.on\n     * @access public\n     * @function on\n     * @param {string} feature - String name of the feature detect\n     * @param {Function} cb - Callback function returning a Boolean - true if feature is supported, false if not\n     * @returns {void}\n     * @example\n     *\n     * ```js\n     * Modernizr.on('flash', function( result ) {\n     *   if (result) {\n     *    // the browser has flash\n     *   } else {\n     *     // the browser does not have flash\n     *   }\n     * });\n     * ```\n     */\n\n    ModernizrProto.on = function (feature, cb) {\n      // Create the list of listeners if it doesn't exist\n      if (!this._l[feature]) {\n        this._l[feature] = [];\n      } // Push this test on to the listener list\n\n\n      this._l[feature].push(cb); // If it's already been resolved, trigger it on next tick\n\n\n      if (Modernizr.hasOwnProperty(feature)) {\n        // Next Tick\n        setTimeout(function () {\n          Modernizr._trigger(feature, Modernizr[feature]);\n        }, 0);\n      }\n    };\n    /**\n     * _trigger is the private function used to signal test completion and run any\n     * callbacks registered through [Modernizr.on](#modernizr-on)\n     *\n     * @memberOf Modernizr\n     * @name Modernizr._trigger\n     * @access private\n     * @function _trigger\n     * @param {string} feature - string name of the feature detect\n     * @param {Function|boolean} [res] - A feature detection function, or the boolean =\n     * result of a feature detection function\n     * @returns {void}\n     */\n\n\n    ModernizrProto._trigger = function (feature, res) {\n      if (!this._l[feature]) {\n        return;\n      }\n\n      var cbs = this._l[feature]; // Force async\n\n      setTimeout(function () {\n        var i, cb;\n\n        for (i = 0; i < cbs.length; i++) {\n          cb = cbs[i];\n          cb(res);\n        }\n      }, 0); // Don't trigger these again\n\n      delete this._l[feature];\n    };\n    /**\n     * addTest allows you to define your own feature detects that are not currently\n     * included in Modernizr (under the covers it's the exact same code Modernizr\n     * uses for its own [feature detections](https://github.com/Modernizr/Modernizr/tree/master/feature-detects)).\n     * Just like the official detects, the result\n     * will be added onto the Modernizr object, as well as an appropriate className set on\n     * the html element when configured to do so\n     *\n     * @memberOf Modernizr\n     * @name Modernizr.addTest\n     * @optionName Modernizr.addTest()\n     * @optionProp addTest\n     * @access public\n     * @function addTest\n     * @param {string|Object} feature - The string name of the feature detect, or an\n     * object of feature detect names and test\n     * @param {Function|boolean} test - Function returning true if feature is supported,\n     * false if not. Otherwise a boolean representing the results of a feature detection\n     * @returns {Object} the Modernizr object to allow chaining\n     * @example\n     *\n     * The most common way of creating your own feature detects is by calling\n     * `Modernizr.addTest` with a string (preferably just lowercase, without any\n     * punctuation), and a function you want executed that will return a boolean result\n     *\n     * ```js\n     * Modernizr.addTest('itsTuesday', function() {\n     *  var d = new Date();\n     *  return d.getDay() === 2;\n     * });\n     * ```\n     *\n     * When the above is run, it will set Modernizr.itstuesday to `true` when it is tuesday,\n     * and to `false` every other day of the week. One thing to notice is that the names of\n     * feature detect functions are always lowercased when added to the Modernizr object. That\n     * means that `Modernizr.itsTuesday` will not exist, but `Modernizr.itstuesday` will.\n     *\n     *\n     *  Since we only look at the returned value from any feature detection function,\n     *  you do not need to actually use a function. For simple detections, just passing\n     *  in a statement that will return a boolean value works just fine.\n     *\n     * ```js\n     * Modernizr.addTest('hasjquery', 'jQuery' in window);\n     * ```\n     *\n     * Just like before, when the above runs `Modernizr.hasjquery` will be true if\n     * jQuery has been included on the page. Not using a function saves a small amount\n     * of overhead for the browser, as well as making your code much more readable.\n     *\n     * Finally, you also have the ability to pass in an object of feature names and\n     * their tests. This is handy if you want to add multiple detections in one go.\n     * The keys should always be a string, and the value can be either a boolean or\n     * function that returns a boolean.\n     *\n     * ```js\n     * var detects = {\n     *  'hasjquery': 'jQuery' in window,\n     *  'itstuesday': function() {\n     *    var d = new Date();\n     *    return d.getDay() === 2;\n     *  }\n     * }\n     *\n     * Modernizr.addTest(detects);\n     * ```\n     *\n     * There is really no difference between the first methods and this one, it is\n     * just a convenience to let you write more readable code.\n     */\n\n\n    function addTest(feature, test) {\n      if (_typeof(feature) === 'object') {\n        for (var key in feature) {\n          if (hasOwnProp(feature, key)) {\n            addTest(key, feature[key]);\n          }\n        }\n      } else {\n        feature = feature.toLowerCase();\n        var featureNameSplit = feature.split('.');\n        var last = Modernizr[featureNameSplit[0]]; // Again, we don't check for parent test existence. Get that right, though.\n\n        if (featureNameSplit.length === 2) {\n          last = last[featureNameSplit[1]];\n        }\n\n        if (typeof last !== 'undefined') {\n          // we're going to quit if you're trying to overwrite an existing test\n          // if we were to allow it, we'd do this:\n          //   var re = new RegExp(\"\\\\b(no-)?\" + feature + \"\\\\b\");\n          //   docElement.className = docElement.className.replace( re, '' );\n          // but, no rly, stuff 'em.\n          return Modernizr;\n        }\n\n        test = typeof test === 'function' ? test() : test; // Set the value (this is the magic, right here).\n\n        if (featureNameSplit.length === 1) {\n          Modernizr[featureNameSplit[0]] = test;\n        } else {\n          // cast to a Boolean, if not one already\n          if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {\n            Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);\n          }\n\n          Modernizr[featureNameSplit[0]][featureNameSplit[1]] = test;\n        } // Set a single class (either `feature` or `no-feature`)\n\n\n        setClasses([(!!test && test !== false ? '' : 'no-') + featureNameSplit.join('-')]); // Trigger the event\n\n        Modernizr._trigger(feature, test);\n      }\n\n      return Modernizr; // allow chaining.\n    } // After all the tests are run, add self to the Modernizr prototype\n\n\n    Modernizr._q.push(function () {\n      ModernizrProto.addTest = addTest;\n    });\n    /**\n     * @optionName html5printshiv\n     * @optionProp html5printshiv\n     */\n    // Take the html5 variable out of the html5shiv scope so we can return it.\n\n\n    var html5;\n\n    if (!isSVG) {\n      /**\n       * @preserve HTML5 Shiv 3.7.3 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed\n       */\n      ;\n\n      (function (window, document) {\n        /*jshint evil:true */\n\n        /** version */\n        var version = '3.7.3';\n        /** Preset options */\n\n        var options = window.html5 || {};\n        /** Used to skip problem elements */\n\n        var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;\n        /** Not all elements can be cloned in IE **/\n\n        var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;\n        /** Detect whether the browser supports default html5 styles */\n\n        var supportsHtml5Styles;\n        /** Name of the expando, to work with multiple documents or to re-shiv one document */\n\n        var expando = '_html5shiv';\n        /** The id for the the documents expando */\n\n        var expanID = 0;\n        /** Cached data for each document */\n\n        var expandoData = {};\n        /** Detect whether the browser supports unknown elements */\n\n        var supportsUnknownElements;\n\n        (function () {\n          try {\n            var a = document.createElement('a');\n            a.innerHTML = '<xyz></xyz>'; //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles\n\n            supportsHtml5Styles = 'hidden' in a;\n\n            supportsUnknownElements = a.childNodes.length == 1 || function () {\n              // assign a false positive if unable to shiv\n              document.createElement('a');\n              var frag = document.createDocumentFragment();\n              return typeof frag.cloneNode == 'undefined' || typeof frag.createDocumentFragment == 'undefined' || typeof frag.createElement == 'undefined';\n            }();\n          } catch (e) {\n            // assign a false positive if detection fails => unable to shiv\n            supportsHtml5Styles = true;\n            supportsUnknownElements = true;\n          }\n        })();\n        /*--------------------------------------------------------------------------*/\n\n        /**\n         * Creates a style sheet with the given CSS text and adds it to the document.\n         * @private\n         * @param {Document} ownerDocument The document.\n         * @param {String} cssText The CSS text.\n         * @returns {StyleSheet} The style element.\n         */\n\n\n        function addStyleSheet(ownerDocument, cssText) {\n          var p = ownerDocument.createElement('p'),\n              parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;\n          p.innerHTML = 'x<style>' + cssText + '</style>';\n          return parent.insertBefore(p.lastChild, parent.firstChild);\n        }\n        /**\n         * Returns the value of `html5.elements` as an array.\n         * @private\n         * @returns {Array} An array of shived element node names.\n         */\n\n\n        function getElements() {\n          var elements = html5.elements;\n          return typeof elements == 'string' ? elements.split(' ') : elements;\n        }\n        /**\n         * Extends the built-in list of html5 elements\n         * @memberOf html5\n         * @param {String|Array} newElements whitespace separated list or array of new element names to shiv\n         * @param {Document} ownerDocument The context document.\n         */\n\n\n        function addElements(newElements, ownerDocument) {\n          var elements = html5.elements;\n\n          if (typeof elements != 'string') {\n            elements = elements.join(' ');\n          }\n\n          if (typeof newElements != 'string') {\n            newElements = newElements.join(' ');\n          }\n\n          html5.elements = elements + ' ' + newElements;\n          shivDocument(ownerDocument);\n        }\n        /**\n         * Returns the data associated to the given document\n         * @private\n         * @param {Document} ownerDocument The document.\n         * @returns {Object} An object of data.\n         */\n\n\n        function getExpandoData(ownerDocument) {\n          var data = expandoData[ownerDocument[expando]];\n\n          if (!data) {\n            data = {};\n            expanID++;\n            ownerDocument[expando] = expanID;\n            expandoData[expanID] = data;\n          }\n\n          return data;\n        }\n        /**\n         * returns a shived element for the given nodeName and document\n         * @memberOf html5\n         * @param {String} nodeName name of the element\n         * @param {Document} ownerDocument The context document.\n         * @returns {Object} The shived element.\n         */\n\n\n        function createElement(nodeName, ownerDocument, data) {\n          if (!ownerDocument) {\n            ownerDocument = document;\n          }\n\n          if (supportsUnknownElements) {\n            return ownerDocument.createElement(nodeName);\n          }\n\n          if (!data) {\n            data = getExpandoData(ownerDocument);\n          }\n\n          var node;\n\n          if (data.cache[nodeName]) {\n            node = data.cache[nodeName].cloneNode();\n          } else if (saveClones.test(nodeName)) {\n            node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();\n          } else {\n            node = data.createElem(nodeName);\n          } // Avoid adding some elements to fragments in IE < 9 because\n          // * Attributes like `name` or `type` cannot be set/changed once an element\n          //   is inserted into a document/fragment\n          // * Link elements with `src` attributes that are inaccessible, as with\n          //   a 403 response, will cause the tab/window to crash\n          // * Script elements appended to fragments will execute when their `src`\n          //   or `text` property is set\n\n\n          return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;\n        }\n        /**\n         * returns a shived DocumentFragment for the given document\n         * @memberOf html5\n         * @param {Document} ownerDocument The context document.\n         * @returns {Object} The shived DocumentFragment.\n         */\n\n\n        function createDocumentFragment(ownerDocument, data) {\n          if (!ownerDocument) {\n            ownerDocument = document;\n          }\n\n          if (supportsUnknownElements) {\n            return ownerDocument.createDocumentFragment();\n          }\n\n          data = data || getExpandoData(ownerDocument);\n          var clone = data.frag.cloneNode(),\n              i = 0,\n              elems = getElements(),\n              l = elems.length;\n\n          for (; i < l; i++) {\n            clone.createElement(elems[i]);\n          }\n\n          return clone;\n        }\n        /**\n         * Shivs the `createElement` and `createDocumentFragment` methods of the document.\n         * @private\n         * @param {Document|DocumentFragment} ownerDocument The document.\n         * @param {Object} data of the document.\n         */\n\n\n        function shivMethods(ownerDocument, data) {\n          if (!data.cache) {\n            data.cache = {};\n            data.createElem = ownerDocument.createElement;\n            data.createFrag = ownerDocument.createDocumentFragment;\n            data.frag = data.createFrag();\n          }\n\n          ownerDocument.createElement = function (nodeName) {\n            //abort shiv\n            if (!html5.shivMethods) {\n              return data.createElem(nodeName);\n            }\n\n            return createElement(nodeName, ownerDocument, data);\n          };\n\n          ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' + 'var n=f.cloneNode(),c=n.createElement;' + 'h.shivMethods&&(' + // unroll the `createElement` calls\n          getElements().join().replace(/[\\w\\-:]+/g, function (nodeName) {\n            data.createElem(nodeName);\n            data.frag.createElement(nodeName);\n            return 'c(\"' + nodeName + '\")';\n          }) + ');return n}')(html5, data.frag);\n        }\n        /*--------------------------------------------------------------------------*/\n\n        /**\n         * Shivs the given document.\n         * @memberOf html5\n         * @param {Document} ownerDocument The document to shiv.\n         * @returns {Document} The shived document.\n         */\n\n\n        function shivDocument(ownerDocument) {\n          if (!ownerDocument) {\n            ownerDocument = document;\n          }\n\n          var data = getExpandoData(ownerDocument);\n\n          if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {\n            data.hasCSS = !!addStyleSheet(ownerDocument, // corrects block display not defined in IE6/7/8/9\n            'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' + // adds styling not present in IE6/7/8/9\n            'mark{background:#FF0;color:#000}' + // hides non-rendered elements\n            'template{display:none}');\n          }\n\n          if (!supportsUnknownElements) {\n            shivMethods(ownerDocument, data);\n          }\n\n          return ownerDocument;\n        }\n        /*--------------------------------------------------------------------------*/\n\n        /**\n         * The `html5` object is exposed so that more elements can be shived and\n         * existing shiving can be detected on iframes.\n         * @type Object\n         * @example\n         *\n         * // options can be changed before the script is included\n         * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };\n         */\n\n\n        var html5 = {\n          /**\n           * An array or space separated string of node names of the elements to shiv.\n           * @memberOf html5\n           * @type Array|String\n           */\n          'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video',\n\n          /**\n           * current version of html5shiv\n           */\n          'version': version,\n\n          /**\n           * A flag to indicate that the HTML5 style sheet should be inserted.\n           * @memberOf html5\n           * @type Boolean\n           */\n          'shivCSS': options.shivCSS !== false,\n\n          /**\n           * Is equal to true if a browser supports creating unknown/HTML5 elements\n           * @memberOf html5\n           * @type boolean\n           */\n          'supportsUnknownElements': supportsUnknownElements,\n\n          /**\n           * A flag to indicate that the document's `createElement` and `createDocumentFragment`\n           * methods should be overwritten.\n           * @memberOf html5\n           * @type Boolean\n           */\n          'shivMethods': options.shivMethods !== false,\n\n          /**\n           * A string to describe the type of `html5` object (\"default\" or \"default print\").\n           * @memberOf html5\n           * @type String\n           */\n          'type': 'default',\n          // shivs the document according to the specified `html5` object options\n          'shivDocument': shivDocument,\n          //creates a shived element\n          createElement: createElement,\n          //creates a shived documentFragment\n          createDocumentFragment: createDocumentFragment,\n          //extends list of elements\n          addElements: addElements\n        };\n        /*--------------------------------------------------------------------------*/\n        // expose html5\n\n        window.html5 = html5; // shiv the document\n\n        shivDocument(document);\n        /*------------------------------- Print Shiv -------------------------------*/\n\n        /** Used to filter media types */\n\n        var reMedia = /^$|\\b(?:all|print)\\b/;\n        /** Used to namespace printable elements */\n\n        var shivNamespace = 'html5shiv';\n        /** Detect whether the browser supports shivable style sheets */\n\n        var supportsShivableSheets = !supportsUnknownElements && function () {\n          // assign a false negative if unable to shiv\n          var docEl = document.documentElement;\n          return !(typeof document.namespaces == 'undefined' || typeof document.parentWindow == 'undefined' || typeof docEl.applyElement == 'undefined' || typeof docEl.removeNode == 'undefined' || typeof window.attachEvent == 'undefined');\n        }();\n        /*--------------------------------------------------------------------------*/\n\n        /**\n         * Wraps all HTML5 elements in the given document with printable elements.\n         * (eg. the \"header\" element is wrapped with the \"html5shiv:header\" element)\n         * @private\n         * @param {Document} ownerDocument The document.\n         * @returns {Array} An array wrappers added.\n         */\n\n\n        function addWrappers(ownerDocument) {\n          var node,\n              nodes = ownerDocument.getElementsByTagName('*'),\n              index = nodes.length,\n              reElements = RegExp('^(?:' + getElements().join('|') + ')$', 'i'),\n              result = [];\n\n          while (index--) {\n            node = nodes[index];\n\n            if (reElements.test(node.nodeName)) {\n              result.push(node.applyElement(createWrapper(node)));\n            }\n          }\n\n          return result;\n        }\n        /**\n         * Creates a printable wrapper for the given element.\n         * @private\n         * @param {Element} element The element.\n         * @returns {Element} The wrapper.\n         */\n\n\n        function createWrapper(element) {\n          var node,\n              nodes = element.attributes,\n              index = nodes.length,\n              wrapper = element.ownerDocument.createElement(shivNamespace + ':' + element.nodeName); // copy element attributes to the wrapper\n\n          while (index--) {\n            node = nodes[index];\n            node.specified && wrapper.setAttribute(node.nodeName, node.nodeValue);\n          } // copy element styles to the wrapper\n\n\n          wrapper.style.cssText = element.style.cssText;\n          return wrapper;\n        }\n        /**\n         * Shivs the given CSS text.\n         * (eg. header{} becomes html5shiv\\:header{})\n         * @private\n         * @param {String} cssText The CSS text to shiv.\n         * @returns {String} The shived CSS text.\n         */\n\n\n        function shivCssText(cssText) {\n          var pair,\n              parts = cssText.split('{'),\n              index = parts.length,\n              reElements = RegExp('(^|[\\\\s,>+~])(' + getElements().join('|') + ')(?=[[\\\\s,>+~#.:]|$)', 'gi'),\n              replacement = '$1' + shivNamespace + '\\\\:$2';\n\n          while (index--) {\n            pair = parts[index] = parts[index].split('}');\n            pair[pair.length - 1] = pair[pair.length - 1].replace(reElements, replacement);\n            parts[index] = pair.join('}');\n          }\n\n          return parts.join('{');\n        }\n        /**\n         * Removes the given wrappers, leaving the original elements.\n         * @private\n         * @params {Array} wrappers An array of printable wrappers.\n         */\n\n\n        function removeWrappers(wrappers) {\n          var index = wrappers.length;\n\n          while (index--) {\n            wrappers[index].removeNode();\n          }\n        }\n        /*--------------------------------------------------------------------------*/\n\n        /**\n         * Shivs the given document for print.\n         * @memberOf html5\n         * @param {Document} ownerDocument The document to shiv.\n         * @returns {Document} The shived document.\n         */\n\n\n        function shivPrint(ownerDocument) {\n          var shivedSheet,\n              wrappers,\n              data = getExpandoData(ownerDocument),\n              namespaces = ownerDocument.namespaces,\n              ownerWindow = ownerDocument.parentWindow;\n\n          if (!supportsShivableSheets || ownerDocument.printShived) {\n            return ownerDocument;\n          }\n\n          if (typeof namespaces[shivNamespace] == 'undefined') {\n            namespaces.add(shivNamespace);\n          }\n\n          function removeSheet() {\n            clearTimeout(data._removeSheetTimer);\n\n            if (shivedSheet) {\n              shivedSheet.removeNode(true);\n            }\n\n            shivedSheet = null;\n          }\n\n          ownerWindow.attachEvent('onbeforeprint', function () {\n            removeSheet();\n            var imports,\n                length,\n                sheet,\n                collection = ownerDocument.styleSheets,\n                cssText = [],\n                index = collection.length,\n                sheets = Array(index); // convert styleSheets collection to an array\n\n            while (index--) {\n              sheets[index] = collection[index];\n            } // concat all style sheet CSS text\n\n\n            while (sheet = sheets.pop()) {\n              // IE does not enforce a same origin policy for external style sheets...\n              // but has trouble with some dynamically created stylesheets\n              if (!sheet.disabled && reMedia.test(sheet.media)) {\n                try {\n                  imports = sheet.imports;\n                  length = imports.length;\n                } catch (er) {\n                  length = 0;\n                }\n\n                for (index = 0; index < length; index++) {\n                  sheets.push(imports[index]);\n                }\n\n                try {\n                  cssText.push(sheet.cssText);\n                } catch (er) {}\n              }\n            } // wrap all HTML5 elements with printable elements and add the shived style sheet\n\n\n            cssText = shivCssText(cssText.reverse().join(''));\n            wrappers = addWrappers(ownerDocument);\n            shivedSheet = addStyleSheet(ownerDocument, cssText);\n          });\n          ownerWindow.attachEvent('onafterprint', function () {\n            // remove wrappers, leaving the original elements, and remove the shived style sheet\n            removeWrappers(wrappers);\n            clearTimeout(data._removeSheetTimer);\n            data._removeSheetTimer = setTimeout(removeSheet, 500);\n          });\n          ownerDocument.printShived = true;\n          return ownerDocument;\n        }\n        /*--------------------------------------------------------------------------*/\n        // expose API\n\n\n        html5.type += ' print';\n        html5.shivPrint = shivPrint; // shiv for print\n\n        shivPrint(document);\n\n        if (( false ? undefined : _typeof(module)) == 'object' && module.exports) {\n          module.exports = html5;\n        }\n      })(typeof window !== \"undefined\" ? window : this, document);\n    }\n\n    ;\n    /**\n     * contains checks to see if a string contains another string\n     *\n     * @access private\n     * @function contains\n     * @param {string} str - The string we want to check for substrings\n     * @param {string} substr - The substring we want to search the first string for\n     * @returns {boolean} true if and only if the first string 'str' contains the second string 'substr'\n     */\n\n    function contains(str, substr) {\n      return !!~('' + str).indexOf(substr);\n    }\n\n    ;\n    /**\n     * createElement is a convenience wrapper around document.createElement. Since we\n     * use createElement all over the place, this allows for (slightly) smaller code\n     * as well as abstracting away issues with creating elements in contexts other than\n     * HTML documents (e.g. SVG documents).\n     *\n     * @access private\n     * @function createElement\n     * @returns {HTMLElement|SVGElement} An HTML or SVG element\n     */\n\n    function createElement() {\n      if (typeof document.createElement !== 'function') {\n        // This is the case in IE7, where the type of createElement is \"object\".\n        // For this reason, we cannot call apply() as Object is not a Function.\n        return document.createElement(arguments[0]);\n      } else if (isSVG) {\n        return document.createElementNS.call(document, 'http://www.w3.org/2000/svg', arguments[0]);\n      } else {\n        return document.createElement.apply(document, arguments);\n      }\n    }\n\n    ;\n    /**\n     * Create our \"modernizr\" element that we do most feature tests on.\n     *\n     * @access private\n     */\n\n    var modElem = {\n      elem: createElement('modernizr')\n    }; // Clean up this element\n\n    Modernizr._q.push(function () {\n      delete modElem.elem;\n    });\n\n    var mStyle = {\n      style: modElem.elem.style\n    }; // kill ref for gc, must happen before mod.elem is removed, so we unshift on to\n    // the front of the queue.\n\n    Modernizr._q.unshift(function () {\n      delete mStyle.style;\n    });\n    /**\n     * getBody returns the body of a document, or an element that can stand in for\n     * the body if a real body does not exist\n     *\n     * @access private\n     * @function getBody\n     * @returns {HTMLElement|SVGElement} Returns the real body of a document, or an\n     * artificially created element that stands in for the body\n     */\n\n\n    function getBody() {\n      // After page load injecting a fake body doesn't work so check if body exists\n      var body = document.body;\n\n      if (!body) {\n        // Can't use the real body create a fake one.\n        body = createElement(isSVG ? 'svg' : 'body');\n        body.fake = true;\n      }\n\n      return body;\n    }\n\n    ;\n    /**\n     * injectElementWithStyles injects an element with style element and some CSS rules\n     *\n     * @access private\n     * @function injectElementWithStyles\n     * @param {string} rule - String representing a css rule\n     * @param {Function} callback - A function that is used to test the injected element\n     * @param {number} [nodes] - An integer representing the number of additional nodes you want injected\n     * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes\n     * @returns {boolean} the result of the specified callback test\n     */\n\n    function injectElementWithStyles(rule, callback, nodes, testnames) {\n      var mod = 'modernizr';\n      var style;\n      var ret;\n      var node;\n      var docOverflow;\n      var div = createElement('div');\n      var body = getBody();\n\n      if (parseInt(nodes, 10)) {\n        // In order not to give false positives we create a node for each test\n        // This also allows the method to scale for unspecified uses\n        while (nodes--) {\n          node = createElement('div');\n          node.id = testnames ? testnames[nodes] : mod + (nodes + 1);\n          div.appendChild(node);\n        }\n      }\n\n      style = createElement('style');\n      style.type = 'text/css';\n      style.id = 's' + mod; // IE6 will false positive on some tests due to the style element inside the test div somehow interfering offsetHeight, so insert it into body or fakebody.\n      // Opera will act all quirky when injecting elements in documentElement when page is served as xml, needs fakebody too. #270\n\n      (!body.fake ? div : body).appendChild(style);\n      body.appendChild(div);\n\n      if (style.styleSheet) {\n        style.styleSheet.cssText = rule;\n      } else {\n        style.appendChild(document.createTextNode(rule));\n      }\n\n      div.id = mod;\n\n      if (body.fake) {\n        //avoid crashing IE8, if background image is used\n        body.style.background = ''; //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible\n\n        body.style.overflow = 'hidden';\n        docOverflow = docElement.style.overflow;\n        docElement.style.overflow = 'hidden';\n        docElement.appendChild(body);\n      }\n\n      ret = callback(div, rule); // If this is done after page load we don't want to remove the body so check if body exists\n\n      if (body.fake) {\n        body.parentNode.removeChild(body);\n        docElement.style.overflow = docOverflow; // Trigger layout so kinetic scrolling isn't disabled in iOS6+\n        // eslint-disable-next-line\n\n        docElement.offsetHeight;\n      } else {\n        div.parentNode.removeChild(div);\n      }\n\n      return !!ret;\n    }\n\n    ;\n    /**\n     * domToCSS takes a camelCase string and converts it to kebab-case\n     * e.g. boxSizing -> box-sizing\n     *\n     * @access private\n     * @function domToCSS\n     * @param {string} name - String name of camelCase prop we want to convert\n     * @returns {string} The kebab-case version of the supplied name\n     */\n\n    function domToCSS(name) {\n      return name.replace(/([A-Z])/g, function (str, m1) {\n        return '-' + m1.toLowerCase();\n      }).replace(/^ms-/, '-ms-');\n    }\n\n    ;\n    /**\n     * wrapper around getComputedStyle, to fix issues with Firefox returning null when\n     * called inside of a hidden iframe\n     *\n     * @access private\n     * @function computedStyle\n     * @param {HTMLElement|SVGElement} elem - The element we want to find the computed styles of\n     * @param {string|null} [pseudo] - An optional pseudo element selector (e.g. :before), of null if none\n     * @param {string} prop - A CSS property\n     * @returns {CSSStyleDeclaration} the value of the specified CSS property\n     */\n\n    function computedStyle(elem, pseudo, prop) {\n      var result;\n\n      if ('getComputedStyle' in window) {\n        result = getComputedStyle.call(window, elem, pseudo);\n        var console = window.console;\n\n        if (result !== null) {\n          if (prop) {\n            result = result.getPropertyValue(prop);\n          }\n        } else {\n          if (console) {\n            var method = console.error ? 'error' : 'log';\n            console[method].call(console, 'getComputedStyle returning null, its possible modernizr test results are inaccurate');\n          }\n        }\n      } else {\n        result = !pseudo && elem.currentStyle && elem.currentStyle[prop];\n      }\n\n      return result;\n    }\n\n    ;\n    /**\n     * nativeTestProps allows for us to use native feature detection functionality if available.\n     * some prefixed form, or false, in the case of an unsupported rule\n     *\n     * @access private\n     * @function nativeTestProps\n     * @param {array} props - An array of property names\n     * @param {string} value - A string representing the value we want to check via @supports\n     * @returns {boolean|undefined} A boolean when @supports exists, undefined otherwise\n     */\n    // Accepts a list of property names and a single value\n    // Returns `undefined` if native detection not available\n\n    function nativeTestProps(props, value) {\n      var i = props.length; // Start with the JS API: https://www.w3.org/TR/css3-conditional/#the-css-interface\n\n      if ('CSS' in window && 'supports' in window.CSS) {\n        // Try every prefixed variant of the property\n        while (i--) {\n          if (window.CSS.supports(domToCSS(props[i]), value)) {\n            return true;\n          }\n        }\n\n        return false;\n      } // Otherwise fall back to at-rule (for Opera 12.x)\n      else if ('CSSSupportsRule' in window) {\n          // Build a condition string for every prefixed variant\n          var conditionText = [];\n\n          while (i--) {\n            conditionText.push('(' + domToCSS(props[i]) + ':' + value + ')');\n          }\n\n          conditionText = conditionText.join(' or ');\n          return injectElementWithStyles('@supports (' + conditionText + ') { #modernizr { position: absolute; } }', function (node) {\n            return computedStyle(node, null, 'position') === 'absolute';\n          });\n        }\n\n      return undefined;\n    }\n\n    ;\n    /**\n     * cssToDOM takes a kebab-case string and converts it to camelCase\n     * e.g. box-sizing -> boxSizing\n     *\n     * @access private\n     * @function cssToDOM\n     * @param {string} name - String name of kebab-case prop we want to convert\n     * @returns {string} The camelCase version of the supplied name\n     */\n\n    function cssToDOM(name) {\n      return name.replace(/([a-z])-([a-z])/g, function (str, m1, m2) {\n        return m1 + m2.toUpperCase();\n      }).replace(/^-/, '');\n    }\n\n    ; // testProps is a generic CSS / DOM property test.\n    // In testing support for a given CSS property, it's legit to test:\n    //    `elem.style[styleName] !== undefined`\n    // If the property is supported it will return an empty string,\n    // if unsupported it will return undefined.\n    // We'll take advantage of this quick test and skip setting a style\n    // on our modernizr element, but instead just testing undefined vs\n    // empty string.\n    // Property names can be provided in either camelCase or kebab-case.\n\n    function testProps(props, prefixed, value, skipValueTest) {\n      skipValueTest = is(skipValueTest, 'undefined') ? false : skipValueTest; // Try native detect first\n\n      if (!is(value, 'undefined')) {\n        var result = nativeTestProps(props, value);\n\n        if (!is(result, 'undefined')) {\n          return result;\n        }\n      } // Otherwise do it properly\n\n\n      var afterInit, i, propsLength, prop, before; // If we don't have a style element, that means we're running async or after\n      // the core tests, so we'll need to create our own elements to use.\n      // Inside of an SVG element, in certain browsers, the `style` element is only\n      // defined for valid tags. Therefore, if `modernizr` does not have one, we\n      // fall back to a less used element and hope for the best.\n      // For strict XHTML browsers the hardly used samp element is used.\n\n      var elems = ['modernizr', 'tspan', 'samp'];\n\n      while (!mStyle.style && elems.length) {\n        afterInit = true;\n        mStyle.modElem = createElement(elems.shift());\n        mStyle.style = mStyle.modElem.style;\n      } // Delete the objects if we created them.\n\n\n      function cleanElems() {\n        if (afterInit) {\n          delete mStyle.style;\n          delete mStyle.modElem;\n        }\n      }\n\n      propsLength = props.length;\n\n      for (i = 0; i < propsLength; i++) {\n        prop = props[i];\n        before = mStyle.style[prop];\n\n        if (contains(prop, '-')) {\n          prop = cssToDOM(prop);\n        }\n\n        if (mStyle.style[prop] !== undefined) {\n          // If value to test has been passed in, do a set-and-check test.\n          // 0 (integer) is a valid property value, so check that `value` isn't\n          // undefined, rather than just checking it's truthy.\n          if (!skipValueTest && !is(value, 'undefined')) {\n            // Needs a try catch block because of old IE. This is slow, but will\n            // be avoided in most cases because `skipValueTest` will be used.\n            try {\n              mStyle.style[prop] = value;\n            } catch (e) {} // If the property value has changed, we assume the value used is\n            // supported. If `value` is empty string, it'll fail here (because\n            // it hasn't changed), which matches how browsers have implemented\n            // CSS.supports()\n\n\n            if (mStyle.style[prop] !== before) {\n              cleanElems();\n              return prefixed === 'pfx' ? prop : true;\n            }\n          } // Otherwise just return true, or the property name if this is a\n          // `prefixed()` call\n          else {\n              cleanElems();\n              return prefixed === 'pfx' ? prop : true;\n            }\n        }\n      }\n\n      cleanElems();\n      return false;\n    }\n\n    ;\n    /**\n     * testProp() investigates whether a given style property is recognized\n     * Property names can be provided in either camelCase or kebab-case.\n     *\n     * @memberOf Modernizr\n     * @name Modernizr.testProp\n     * @access public\n     * @optionName Modernizr.testProp()\n     * @optionProp testProp\n     * @function testProp\n     * @param {string} prop - Name of the CSS property to check\n     * @param {string} [value] - Name of the CSS value to check\n     * @param {boolean} [useValue] - Whether or not to check the value if @supports isn't supported\n     * @returns {boolean} an empty string if the property is supported, undefined if its unsupported\n     * @example\n     *\n     * Just like [testAllProps](#modernizr-testallprops), only it does not check any vendor prefixed\n     * version of the string.\n     *\n     * Note that the property name must be provided in camelCase (e.g. boxSizing not box-sizing)\n     *\n     * ```js\n     * Modernizr.testProp('pointerEvents')  // true\n     * ```\n     *\n     * You can also provide a value as an optional second argument to check if a\n     * specific value is supported\n     *\n     * ```js\n     * Modernizr.testProp('pointerEvents', 'none') // true\n     * Modernizr.testProp('pointerEvents', 'penguin') // false\n     * ```\n     */\n\n    var testProp = ModernizrProto.testProp = function (prop, value, useValue) {\n      return testProps([prop], undefined, value, useValue);\n    }; // Run each test\n\n\n    testRunner(); // Remove the \"no-js\" class if it exists\n\n    setClasses(classes);\n    delete ModernizrProto.addTest;\n    delete ModernizrProto.addAsyncTest; // Run the things that are supposed to run after the tests\n\n    for (var i = 0; i < Modernizr._q.length; i++) {\n      Modernizr._q[i]();\n    } // Leak Modernizr namespace\n\n\n    window.Modernizr = Modernizr;\n    ;\n  })(window, document);\n\n  module.exports = window.Modernizr;\n\n  if (hadGlobal) {\n    window.Modernizr = oldGlobal;\n  } else {\n    delete window.Modernizr;\n  }\n})(window);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi8ubW9kZXJuaXpycmMuanM/MWM1NCJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJoYWRHbG9iYWwiLCJvbGRHbG9iYWwiLCJNb2Rlcm5penIiLCJkb2N1bWVudCIsInVuZGVmaW5lZCIsInRlc3RzIiwiTW9kZXJuaXpyUHJvdG8iLCJfdmVyc2lvbiIsIl9jb25maWciLCJfcSIsIm9uIiwidGVzdCIsImNiIiwic2VsZiIsInNldFRpbWVvdXQiLCJhZGRUZXN0IiwibmFtZSIsImZuIiwib3B0aW9ucyIsInB1c2giLCJhZGRBc3luY1Rlc3QiLCJwcm90b3R5cGUiLCJjbGFzc2VzIiwiaXMiLCJvYmoiLCJ0eXBlIiwidGVzdFJ1bm5lciIsImZlYXR1cmVOYW1lcyIsImZlYXR1cmUiLCJhbGlhc0lkeCIsInJlc3VsdCIsIm5hbWVJZHgiLCJmZWF0dXJlTmFtZSIsImZlYXR1cmVOYW1lU3BsaXQiLCJmZWF0dXJlSWR4IiwiaGFzT3duUHJvcGVydHkiLCJ0b0xvd2VyQ2FzZSIsImFsaWFzZXMiLCJsZW5ndGgiLCJzcGxpdCIsIkJvb2xlYW4iLCJqb2luIiwiZG9jRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImlzU1ZHIiwibm9kZU5hbWUiLCJzZXRDbGFzc2VzIiwiY2xhc3NOYW1lIiwiY2xhc3NQcmVmaXgiLCJiYXNlVmFsIiwiZW5hYmxlSlNDbGFzcyIsInJlSlMiLCJSZWdFeHAiLCJyZXBsYWNlIiwiZW5hYmxlQ2xhc3NlcyIsImhhc093blByb3AiLCJfaGFzT3duUHJvcGVydHkiLCJjYWxsIiwib2JqZWN0IiwicHJvcGVydHkiLCJjb25zdHJ1Y3RvciIsIl9sIiwiX3RyaWdnZXIiLCJyZXMiLCJjYnMiLCJpIiwia2V5IiwibGFzdCIsImh0bWw1IiwidmVyc2lvbiIsInJlU2tpcCIsInNhdmVDbG9uZXMiLCJzdXBwb3J0c0h0bWw1U3R5bGVzIiwiZXhwYW5kbyIsImV4cGFuSUQiLCJleHBhbmRvRGF0YSIsInN1cHBvcnRzVW5rbm93bkVsZW1lbnRzIiwiYSIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJjaGlsZE5vZGVzIiwiZnJhZyIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJjbG9uZU5vZGUiLCJlIiwiYWRkU3R5bGVTaGVldCIsIm93bmVyRG9jdW1lbnQiLCJjc3NUZXh0IiwicCIsInBhcmVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5zZXJ0QmVmb3JlIiwibGFzdENoaWxkIiwiZmlyc3RDaGlsZCIsImdldEVsZW1lbnRzIiwiZWxlbWVudHMiLCJhZGRFbGVtZW50cyIsIm5ld0VsZW1lbnRzIiwic2hpdkRvY3VtZW50IiwiZ2V0RXhwYW5kb0RhdGEiLCJkYXRhIiwibm9kZSIsImNhY2hlIiwiY3JlYXRlRWxlbSIsImNhbkhhdmVDaGlsZHJlbiIsInRhZ1VybiIsImFwcGVuZENoaWxkIiwiY2xvbmUiLCJlbGVtcyIsImwiLCJzaGl2TWV0aG9kcyIsImNyZWF0ZUZyYWciLCJGdW5jdGlvbiIsInNoaXZDU1MiLCJoYXNDU1MiLCJyZU1lZGlhIiwic2hpdk5hbWVzcGFjZSIsInN1cHBvcnRzU2hpdmFibGVTaGVldHMiLCJkb2NFbCIsIm5hbWVzcGFjZXMiLCJwYXJlbnRXaW5kb3ciLCJhcHBseUVsZW1lbnQiLCJyZW1vdmVOb2RlIiwiYXR0YWNoRXZlbnQiLCJhZGRXcmFwcGVycyIsIm5vZGVzIiwiaW5kZXgiLCJyZUVsZW1lbnRzIiwiY3JlYXRlV3JhcHBlciIsImVsZW1lbnQiLCJhdHRyaWJ1dGVzIiwid3JhcHBlciIsInNwZWNpZmllZCIsInNldEF0dHJpYnV0ZSIsIm5vZGVWYWx1ZSIsInN0eWxlIiwic2hpdkNzc1RleHQiLCJwYWlyIiwicGFydHMiLCJyZXBsYWNlbWVudCIsInJlbW92ZVdyYXBwZXJzIiwid3JhcHBlcnMiLCJzaGl2UHJpbnQiLCJzaGl2ZWRTaGVldCIsIm93bmVyV2luZG93IiwicHJpbnRTaGl2ZWQiLCJhZGQiLCJyZW1vdmVTaGVldCIsImNsZWFyVGltZW91dCIsIl9yZW1vdmVTaGVldFRpbWVyIiwiaW1wb3J0cyIsInNoZWV0IiwiY29sbGVjdGlvbiIsInN0eWxlU2hlZXRzIiwic2hlZXRzIiwiQXJyYXkiLCJwb3AiLCJkaXNhYmxlZCIsIm1lZGlhIiwiZXIiLCJyZXZlcnNlIiwibW9kdWxlIiwiZXhwb3J0cyIsImNvbnRhaW5zIiwic3RyIiwic3Vic3RyIiwiaW5kZXhPZiIsImFyZ3VtZW50cyIsImNyZWF0ZUVsZW1lbnROUyIsImFwcGx5IiwibW9kRWxlbSIsImVsZW0iLCJtU3R5bGUiLCJ1bnNoaWZ0IiwiZ2V0Qm9keSIsImJvZHkiLCJmYWtlIiwiaW5qZWN0RWxlbWVudFdpdGhTdHlsZXMiLCJydWxlIiwiY2FsbGJhY2siLCJ0ZXN0bmFtZXMiLCJtb2QiLCJyZXQiLCJkb2NPdmVyZmxvdyIsImRpdiIsInBhcnNlSW50IiwiaWQiLCJzdHlsZVNoZWV0IiwiY3JlYXRlVGV4dE5vZGUiLCJiYWNrZ3JvdW5kIiwib3ZlcmZsb3ciLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJvZmZzZXRIZWlnaHQiLCJkb21Ub0NTUyIsIm0xIiwiY29tcHV0ZWRTdHlsZSIsInBzZXVkbyIsInByb3AiLCJnZXRDb21wdXRlZFN0eWxlIiwiY29uc29sZSIsImdldFByb3BlcnR5VmFsdWUiLCJtZXRob2QiLCJlcnJvciIsImN1cnJlbnRTdHlsZSIsIm5hdGl2ZVRlc3RQcm9wcyIsInByb3BzIiwidmFsdWUiLCJDU1MiLCJzdXBwb3J0cyIsImNvbmRpdGlvblRleHQiLCJjc3NUb0RPTSIsIm0yIiwidG9VcHBlckNhc2UiLCJ0ZXN0UHJvcHMiLCJwcmVmaXhlZCIsInNraXBWYWx1ZVRlc3QiLCJhZnRlckluaXQiLCJwcm9wc0xlbmd0aCIsImJlZm9yZSIsInNoaWZ0IiwiY2xlYW5FbGVtcyIsInRlc3RQcm9wIiwidXNlVmFsdWUiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBQUMsQ0FBQyxVQUFTQSxNQUFULEVBQWdCO0FBQ2xCLE1BQUlDLFNBQVMsR0FBRyxlQUFlRCxNQUEvQjtBQUNBLE1BQUlFLFNBQVMsR0FB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QTIzQ3JDOztBQUNBLFNBQUssSUFBSTZDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcvRCxTQUFTLENBQUNPLEVBQVYsQ0FBYTZCLE1BQWpDLEVBQXlDMkIsQ0FBQyxFQUExQyxFQUE4QztBQUM1Qy9ELGVBQVMsQ0FBQ08sRUFBVixDQUFhd0QsQ0FBYjtBQUNELEtBOTNDb0MsQ0FnNENyQzs7O0FBQ0FsRSxVQUFNLENBQUNHLFNBQVAsR0FBbUJBLFNBQW5CO0FBR0Y7QUFFQyxHQXQ0Q0EsRUFzNENFSCxNQXQ0Q0YsRUFzNENVSSxRQXQ0Q1Y7O0FBdzRDRDhKLFFBQU0sQ0FBQ0MsT0FBUCxHQUFpQm5LLE1BQU0sQ0FBQ0csU0FBeEI7O0FBQ0EsTUFBSUYsU0FBSixFQUFlO0FBQUVELFVBQU0sQ0FBQ0csU0FBUCxHQUFtQkQsU0FBbkI7QUFBK0IsR0FBaEQsTUFDSztBQUFFLFdBQU9GLE1BQU0sQ0FBQ0csU0FBZDtBQUEwQjtBQUNoQyxDQXY2Q0EsRUF1NkNFSCxNQXY2Q0YsRSIsImZpbGUiOiIuLy5tb2Rlcm5penJyYy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24od2luZG93KXtcbnZhciBoYWRHbG9iYWwgPSAnTW9kZXJuaXpyJyBpbiB3aW5kb3c7XG52YXIgb2xkR2xvYmFsID0gd2luZG93Lk1vZGVybml6cjtcbi8qIVxuICogbW9kZXJuaXpyIHYzLjguMFxuICogQnVpbGQgaHR0cHM6Ly9tb2Rlcm5penIuY29tL2Rvd25sb2FkPy1hZGR0ZXN0LXByaW50c2hpdi1zZXRjbGFzc2VzLXRlc3Rwcm9wLWRvbnRtaW5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpXG4gKiAgRmFydWsgQXRlc1xuICogIFBhdWwgSXJpc2hcbiAqICBBbGV4IFNleHRvblxuICogIFJ5YW4gU2VkZG9uXG4gKiAgUGF0cmljayBLZXR0bmVyXG4gKiAgU3R1IENveFxuICogIFJpY2hhcmQgSGVycmVyYVxuICogIFZlZWNrXG5cbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxuLypcbiAqIE1vZGVybml6ciB0ZXN0cyB3aGljaCBuYXRpdmUgQ1NTMyBhbmQgSFRNTDUgZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGVcbiAqIGN1cnJlbnQgVUEgYW5kIG1ha2VzIHRoZSByZXN1bHRzIGF2YWlsYWJsZSB0byB5b3UgaW4gdHdvIHdheXM6IGFzIHByb3BlcnRpZXMgb25cbiAqIGEgZ2xvYmFsIGBNb2Rlcm5penJgIG9iamVjdCwgYW5kIGFzIGNsYXNzZXMgb24gdGhlIGA8aHRtbD5gIGVsZW1lbnQuIFRoaXNcbiAqIGluZm9ybWF0aW9uIGFsbG93cyB5b3UgdG8gcHJvZ3Jlc3NpdmVseSBlbmhhbmNlIHlvdXIgcGFnZXMgd2l0aCBhIGdyYW51bGFyIGxldmVsXG4gKiBvZiBjb250cm9sIG92ZXIgdGhlIGV4cGVyaWVuY2UuXG4qL1xuXG47KGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCl7XG5cbiAgdmFyIHRlc3RzID0gW107XG4gIFxuXG4gIC8qKlxuICAgKiBNb2Rlcm5penJQcm90byBpcyB0aGUgY29uc3RydWN0b3IgZm9yIE1vZGVybml6clxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFjY2VzcyBwdWJsaWNcbiAgICovXG4gIHZhciBNb2Rlcm5penJQcm90byA9IHtcbiAgICAvLyBUaGUgY3VycmVudCB2ZXJzaW9uLCBkdW1teVxuICAgIF92ZXJzaW9uOiAnMy44LjAnLFxuXG4gICAgLy8gQW55IHNldHRpbmdzIHRoYXQgZG9uJ3Qgd29yayBhcyBzZXBhcmF0ZSBtb2R1bGVzXG4gICAgLy8gY2FuIGdvIGluIGhlcmUgYXMgY29uZmlndXJhdGlvbi5cbiAgICBfY29uZmlnOiB7XG4gICAgICAnY2xhc3NQcmVmaXgnOiAnJyxcbiAgICAgICdlbmFibGVDbGFzc2VzJzogdHJ1ZSxcbiAgICAgICdlbmFibGVKU0NsYXNzJzogdHJ1ZSxcbiAgICAgICd1c2VQcmVmaXhlcyc6IHRydWVcbiAgICB9LFxuXG4gICAgLy8gUXVldWUgb2YgdGVzdHNcbiAgICBfcTogW10sXG5cbiAgICAvLyBTdHViIHRoZXNlIGZvciBwZW9wbGUgd2hvIGFyZSBsaXN0ZW5pbmdcbiAgICBvbjogZnVuY3Rpb24odGVzdCwgY2IpIHtcbiAgICAgIC8vIEkgZG9uJ3QgcmVhbGx5IHRoaW5rIHBlb3BsZSBzaG91bGQgZG8gdGhpcywgYnV0IHdlIGNhblxuICAgICAgLy8gc2FmZSBndWFyZCBpdCBhIGJpdC5cbiAgICAgIC8vIC0tIE5PVEU6OiB0aGlzIGdldHMgV0FZIG92ZXJyaWRkZW4gaW4gc3JjL2FkZFRlc3QgZm9yIGFjdHVhbCBhc3luYyB0ZXN0cy5cbiAgICAgIC8vIFRoaXMgaXMgaW4gY2FzZSBwZW9wbGUgbGlzdGVuIHRvIHN5bmNocm9ub3VzIHRlc3RzLiBJIHdvdWxkIGxlYXZlIGl0IG91dCxcbiAgICAgIC8vIGJ1dCB0aGUgY29kZSB0byAqZGlzYWxsb3cqIHN5bmMgdGVzdHMgaW4gdGhlIHJlYWwgdmVyc2lvbiBvZiB0aGlzXG4gICAgICAvLyBmdW5jdGlvbiBpcyBhY3R1YWxseSBsYXJnZXIgdGhhbiB0aGlzLlxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2Ioc2VsZlt0ZXN0XSk7XG4gICAgICB9LCAwKTtcbiAgICB9LFxuXG4gICAgYWRkVGVzdDogZnVuY3Rpb24obmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgICAgIHRlc3RzLnB1c2goe25hbWU6IG5hbWUsIGZuOiBmbiwgb3B0aW9uczogb3B0aW9uc30pO1xuICAgIH0sXG5cbiAgICBhZGRBc3luY1Rlc3Q6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICB0ZXN0cy5wdXNoKHtuYW1lOiBudWxsLCBmbjogZm59KTtcbiAgICB9XG4gIH07XG5cbiAgXG5cbiAgLy8gRmFrZSBzb21lIG9mIE9iamVjdC5jcmVhdGUgc28gd2UgY2FuIGZvcmNlIG5vbiB0ZXN0IHJlc3VsdHMgdG8gYmUgbm9uIFwib3duXCIgcHJvcGVydGllcy5cbiAgdmFyIE1vZGVybml6ciA9IGZ1bmN0aW9uKCkge307XG4gIE1vZGVybml6ci5wcm90b3R5cGUgPSBNb2Rlcm5penJQcm90bztcblxuICAvLyBMZWFrIG1vZGVybml6ciBnbG9iYWxseSB3aGVuIHlvdSBgcmVxdWlyZWAgaXQgcmF0aGVyIHRoYW4gZm9yY2UgaXQgaGVyZS5cbiAgLy8gT3ZlcndyaXRlIG5hbWUgc28gY29uc3RydWN0b3IgbmFtZSBpcyBuaWNlciA6RFxuICBNb2Rlcm5penIgPSBuZXcgTW9kZXJuaXpyKCk7XG5cbiAgXG5cbiAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgXG5cbiAgLyoqXG4gICAqIGlzIHJldHVybnMgYSBib29sZWFuIGlmIHRoZSB0eXBlb2YgYW4gb2JqIGlzIGV4YWN0bHkgdHlwZS5cbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBpc1xuICAgKiBAcGFyYW0geyp9IG9iaiAtIEEgdGhpbmcgd2Ugd2FudCB0byBjaGVjayB0aGUgdHlwZSBvZlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEEgc3RyaW5nIHRvIGNvbXBhcmUgdGhlIHR5cGVvZiBhZ2FpbnN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0eXBlb2YgdGhlIGZpcnN0IHBhcmFtZXRlciBpcyBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBmdW5jdGlvbiBpcyhvYmosIHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gdHlwZTtcbiAgfVxuXG4gIDtcblxuICAvKipcbiAgICogUnVuIHRocm91Z2ggYWxsIHRlc3RzIGFuZCBkZXRlY3QgdGhlaXIgc3VwcG9ydCBpbiB0aGUgY3VycmVudCBVQS5cbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gdGVzdFJ1bm5lcigpIHtcbiAgICB2YXIgZmVhdHVyZU5hbWVzO1xuICAgIHZhciBmZWF0dXJlO1xuICAgIHZhciBhbGlhc0lkeDtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBmZWF0dXJlTmFtZTtcbiAgICB2YXIgZmVhdHVyZU5hbWVTcGxpdDtcblxuICAgIGZvciAodmFyIGZlYXR1cmVJZHggaW4gdGVzdHMpIHtcbiAgICAgIGlmICh0ZXN0cy5oYXNPd25Qcm9wZXJ0eShmZWF0dXJlSWR4KSkge1xuICAgICAgICBmZWF0dXJlTmFtZXMgPSBbXTtcbiAgICAgICAgZmVhdHVyZSA9IHRlc3RzW2ZlYXR1cmVJZHhdO1xuICAgICAgICAvLyBydW4gdGhlIHRlc3QsIHRocm93IHRoZSByZXR1cm4gdmFsdWUgaW50byB0aGUgTW9kZXJuaXpyLFxuICAgICAgICAvLyB0aGVuIGJhc2VkIG9uIHRoYXQgYm9vbGVhbiwgZGVmaW5lIGFuIGFwcHJvcHJpYXRlIGNsYXNzTmFtZVxuICAgICAgICAvLyBhbmQgcHVzaCBpdCBpbnRvIGFuIGFycmF5IG9mIGNsYXNzZXMgd2UnbGwgam9pbiBsYXRlci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbmFtZSwgaXQncyBhbiAnYXN5bmMnIHRlc3QgdGhhdCBpcyBydW4sXG4gICAgICAgIC8vIGJ1dCBub3QgZGlyZWN0bHkgYWRkZWQgdG8gdGhlIG9iamVjdC4gVGhhdCBzaG91bGRcbiAgICAgICAgLy8gYmUgZG9uZSB3aXRoIGEgcG9zdC1ydW4gYWRkVGVzdCBjYWxsLlxuICAgICAgICBpZiAoZmVhdHVyZS5uYW1lKSB7XG4gICAgICAgICAgZmVhdHVyZU5hbWVzLnB1c2goZmVhdHVyZS5uYW1lLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgaWYgKGZlYXR1cmUub3B0aW9ucyAmJiBmZWF0dXJlLm9wdGlvbnMuYWxpYXNlcyAmJiBmZWF0dXJlLm9wdGlvbnMuYWxpYXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhbGwgdGhlIGFsaWFzZXMgaW50byB0aGUgbmFtZXMgbGlzdFxuICAgICAgICAgICAgZm9yIChhbGlhc0lkeCA9IDA7IGFsaWFzSWR4IDwgZmVhdHVyZS5vcHRpb25zLmFsaWFzZXMubGVuZ3RoOyBhbGlhc0lkeCsrKSB7XG4gICAgICAgICAgICAgIGZlYXR1cmVOYW1lcy5wdXNoKGZlYXR1cmUub3B0aW9ucy5hbGlhc2VzW2FsaWFzSWR4XS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdW4gdGhlIHRlc3QsIG9yIHVzZSB0aGUgcmF3IHZhbHVlIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb25cbiAgICAgICAgcmVzdWx0ID0gaXMoZmVhdHVyZS5mbiwgJ2Z1bmN0aW9uJykgPyBmZWF0dXJlLmZuKCkgOiBmZWF0dXJlLmZuO1xuXG4gICAgICAgIC8vIFNldCBlYWNoIG9mIHRoZSBuYW1lcyBvbiB0aGUgTW9kZXJuaXpyIG9iamVjdFxuICAgICAgICBmb3IgKG5hbWVJZHggPSAwOyBuYW1lSWR4IDwgZmVhdHVyZU5hbWVzLmxlbmd0aDsgbmFtZUlkeCsrKSB7XG4gICAgICAgICAgZmVhdHVyZU5hbWUgPSBmZWF0dXJlTmFtZXNbbmFtZUlkeF07XG4gICAgICAgICAgLy8gU3VwcG9ydCBkb3QgcHJvcGVydGllcyBhcyBzdWIgdGVzdHMuIFdlIGRvbid0IGRvIGNoZWNraW5nIHRvIG1ha2Ugc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGltcGxpZWQgcGFyZW50IHRlc3RzIGhhdmUgYmVlbiBhZGRlZC4gWW91IG11c3QgY2FsbCB0aGVtIGluXG4gICAgICAgICAgLy8gb3JkZXIgKGVpdGhlciBpbiB0aGUgdGVzdCwgb3IgbWFrZSB0aGUgcGFyZW50IHRlc3QgYSBkZXBlbmRlbmN5KS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIENhcCBpdCB0byBUV08gdG8gbWFrZSB0aGUgbG9naWMgc2ltcGxlIGFuZCBiZWNhdXNlIHdobyBuZWVkcyB0aGF0IGtpbmQgb2Ygc3VidGVzdGluZ1xuICAgICAgICAgIC8vIGhhc2h0YWcgZmFtb3VzIGxhc3Qgd29yZHNcbiAgICAgICAgICBmZWF0dXJlTmFtZVNwbGl0ID0gZmVhdHVyZU5hbWUuc3BsaXQoJy4nKTtcblxuICAgICAgICAgIGlmIChmZWF0dXJlTmFtZVNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgTW9kZXJuaXpyW2ZlYXR1cmVOYW1lU3BsaXRbMF1dID0gcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjYXN0IHRvIGEgQm9vbGVhbiwgaWYgbm90IG9uZSBhbHJlYWR5IG9yIGlmIGl0IGRvZXNudCBleGlzdCB5ZXQgKGxpa2UgaW5wdXR0eXBlcylcbiAgICAgICAgICAgIGlmICghTW9kZXJuaXpyW2ZlYXR1cmVOYW1lU3BsaXRbMF1dIHx8IE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSAmJiAhKE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSBpbnN0YW5jZW9mIEJvb2xlYW4pKSB7XG4gICAgICAgICAgICAgIE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSA9IG5ldyBCb29sZWFuKE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXVtmZWF0dXJlTmFtZVNwbGl0WzFdXSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGFzc2VzLnB1c2goKHJlc3VsdCA/ICcnIDogJ25vLScpICsgZmVhdHVyZU5hbWVTcGxpdC5qb2luKCctJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIDtcblxuICAvKipcbiAgICogZG9jRWxlbWVudCBpcyBhIGNvbnZlbmllbmNlIHdyYXBwZXIgdG8gZ3JhYiB0aGUgcm9vdCBlbGVtZW50IG9mIHRoZSBkb2N1bWVudFxuICAgKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IFRoZSByb290IGVsZW1lbnQgb2YgdGhlIGRvY3VtZW50XG4gICAqL1xuICB2YXIgZG9jRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgaGVscGVyIHRvIGNoZWNrIGlmIHRoZSBkb2N1bWVudCB3ZSBhcmUgcnVubmluZyBpbiBpcyBhbiBTVkcgZG9jdW1lbnRcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmFyIGlzU1ZHID0gZG9jRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJztcblxuICBcblxuICAvKipcbiAgICogc2V0Q2xhc3NlcyB0YWtlcyBhbiBhcnJheSBvZiBjbGFzcyBuYW1lcyBhbmQgYWRkcyB0aGVtIHRvIHRoZSByb290IGVsZW1lbnRcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBzZXRDbGFzc2VzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGNsYXNzZXMgLSBBcnJheSBvZiBjbGFzcyBuYW1lc1xuICAgKi9cbiAgLy8gUGFzcyBpbiBhbiBhbmQgYXJyYXkgb2YgY2xhc3MgbmFtZXMsIGUuZy46XG4gIC8vICBbJ25vLXdlYnAnLCAnYm9yZGVycmFkaXVzJywgLi4uXVxuICBmdW5jdGlvbiBzZXRDbGFzc2VzKGNsYXNzZXMpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gZG9jRWxlbWVudC5jbGFzc05hbWU7XG4gICAgdmFyIGNsYXNzUHJlZml4ID0gTW9kZXJuaXpyLl9jb25maWcuY2xhc3NQcmVmaXggfHwgJyc7XG5cbiAgICBpZiAoaXNTVkcpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5iYXNlVmFsO1xuICAgIH1cblxuICAgIC8vIENoYW5nZSBgbm8tanNgIHRvIGBqc2AgKGluZGVwZW5kZW50bHkgb2YgdGhlIGBlbmFibGVDbGFzc2VzYCBvcHRpb24pXG4gICAgLy8gSGFuZGxlIGNsYXNzUHJlZml4IG9uIHRoaXMgdG9vXG4gICAgaWYgKE1vZGVybml6ci5fY29uZmlnLmVuYWJsZUpTQ2xhc3MpIHtcbiAgICAgIHZhciByZUpTID0gbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIGNsYXNzUHJlZml4ICsgJ25vLWpzKFxcXFxzfCQpJyk7XG4gICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUucmVwbGFjZShyZUpTLCAnJDEnICsgY2xhc3NQcmVmaXggKyAnanMkMicpO1xuICAgIH1cblxuICAgIGlmIChNb2Rlcm5penIuX2NvbmZpZy5lbmFibGVDbGFzc2VzKSB7XG4gICAgICAvLyBBZGQgdGhlIG5ldyBjbGFzc2VzXG4gICAgICBpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSAnICcgKyBjbGFzc1ByZWZpeCArIGNsYXNzZXMuam9pbignICcgKyBjbGFzc1ByZWZpeCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgZG9jRWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCA9IGNsYXNzTmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY0VsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIDtcblxuICAvKipcbiAgICogaGFzT3duUHJvcCBpcyBhIHNoaW0gZm9yIGhhc093blByb3BlcnR5IHRoYXQgaXMgbmVlZGVkIGZvciBTYWZhcmkgMi4wIHN1cHBvcnRcbiAgICpcbiAgICogQGF1dGhvciBrYW5nYXhcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBoYXNPd25Qcm9wXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIGNoZWNrIGZvciBhIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSBwcm9wZXJ0eSB0byBjaGVjayBmb3JcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG4gIC8vIGhhc093blByb3BlcnR5IHNoaW0gYnkga2FuZ2F4IG5lZWRlZCBmb3IgU2FmYXJpIDIuMCBzdXBwb3J0XG4gIHZhciBoYXNPd25Qcm9wO1xuXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgX2hhc093blByb3BlcnR5ID0gKHt9KS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIC8qIHdlIGhhdmUgbm8gd2F5IG9mIHRlc3RpbmcgSUUgNS41IG9yIHNhZmFyaSAyLFxuICAgICAqIHNvIGp1c3QgYXNzdW1lIHRoZSBlbHNlIGdldHMgaGl0ICovXG4gICAgaWYgKCFpcyhfaGFzT3duUHJvcGVydHksICd1bmRlZmluZWQnKSAmJiAhaXMoX2hhc093blByb3BlcnR5LmNhbGwsICd1bmRlZmluZWQnKSkge1xuICAgICAgaGFzT3duUHJvcCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoYXNPd25Qcm9wID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyAvKiB5ZXMsIHRoaXMgY2FuIGdpdmUgZmFsc2UgcG9zaXRpdmVzL25lZ2F0aXZlcywgYnV0IG1vc3Qgb2YgdGhlIHRpbWUgd2UgZG9uJ3QgY2FyZSBhYm91dCB0aG9zZSAqL1xuICAgICAgICByZXR1cm4gKChwcm9wZXJ0eSBpbiBvYmplY3QpICYmIGlzKG9iamVjdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbcHJvcGVydHldLCAndW5kZWZpbmVkJykpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgXG5cblxuICAvLyBfbCB0cmFja3MgbGlzdGVuZXJzIGZvciBhc3luYyB0ZXN0cywgYXMgd2VsbCBhcyB0ZXN0cyB0aGF0IGV4ZWN1dGUgYWZ0ZXIgdGhlIGluaXRpYWwgcnVuXG4gIE1vZGVybml6clByb3RvLl9sID0ge307XG5cbiAgLyoqXG4gICAqIE1vZGVybml6ci5vbiBpcyBhIHdheSB0byBsaXN0ZW4gZm9yIHRoZSBjb21wbGV0aW9uIG9mIGFzeW5jIHRlc3RzLiBCZWluZ1xuICAgKiBhc3luY2hyb25vdXMsIHRoZXkgbWF5IG5vdCBmaW5pc2ggYmVmb3JlIHlvdXIgc2NyaXB0cyBydW4uIEFzIGEgcmVzdWx0IHlvdVxuICAgKiB3aWxsIGdldCBhIHBvc3NpYmx5IGZhbHNlIG5lZ2F0aXZlIGB1bmRlZmluZWRgIHZhbHVlLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTW9kZXJuaXpyXG4gICAqIEBuYW1lIE1vZGVybml6ci5vblxuICAgKiBAYWNjZXNzIHB1YmxpY1xuICAgKiBAZnVuY3Rpb24gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSBTdHJpbmcgbmFtZSBvZiB0aGUgZmVhdHVyZSBkZXRlY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBDYWxsYmFjayBmdW5jdGlvbiByZXR1cm5pbmcgYSBCb29sZWFuIC0gdHJ1ZSBpZiBmZWF0dXJlIGlzIHN1cHBvcnRlZCwgZmFsc2UgaWYgbm90XG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBNb2Rlcm5penIub24oJ2ZsYXNoJywgZnVuY3Rpb24oIHJlc3VsdCApIHtcbiAgICogICBpZiAocmVzdWx0KSB7XG4gICAqICAgIC8vIHRoZSBicm93c2VyIGhhcyBmbGFzaFxuICAgKiAgIH0gZWxzZSB7XG4gICAqICAgICAvLyB0aGUgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGZsYXNoXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBNb2Rlcm5penJQcm90by5vbiA9IGZ1bmN0aW9uKGZlYXR1cmUsIGNiKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBsaXN0IG9mIGxpc3RlbmVycyBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCF0aGlzLl9sW2ZlYXR1cmVdKSB7XG4gICAgICB0aGlzLl9sW2ZlYXR1cmVdID0gW107XG4gICAgfVxuXG4gICAgLy8gUHVzaCB0aGlzIHRlc3Qgb24gdG8gdGhlIGxpc3RlbmVyIGxpc3RcbiAgICB0aGlzLl9sW2ZlYXR1cmVdLnB1c2goY2IpO1xuXG4gICAgLy8gSWYgaXQncyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQsIHRyaWdnZXIgaXQgb24gbmV4dCB0aWNrXG4gICAgaWYgKE1vZGVybml6ci5oYXNPd25Qcm9wZXJ0eShmZWF0dXJlKSkge1xuICAgICAgLy8gTmV4dCBUaWNrXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBNb2Rlcm5penIuX3RyaWdnZXIoZmVhdHVyZSwgTW9kZXJuaXpyW2ZlYXR1cmVdKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogX3RyaWdnZXIgaXMgdGhlIHByaXZhdGUgZnVuY3Rpb24gdXNlZCB0byBzaWduYWwgdGVzdCBjb21wbGV0aW9uIGFuZCBydW4gYW55XG4gICAqIGNhbGxiYWNrcyByZWdpc3RlcmVkIHRocm91Z2ggW01vZGVybml6ci5vbl0oI21vZGVybml6ci1vbilcbiAgICpcbiAgICogQG1lbWJlck9mIE1vZGVybml6clxuICAgKiBAbmFtZSBNb2Rlcm5penIuX3RyaWdnZXJcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBfdHJpZ2dlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIHN0cmluZyBuYW1lIG9mIHRoZSBmZWF0dXJlIGRldGVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufGJvb2xlYW59IFtyZXNdIC0gQSBmZWF0dXJlIGRldGVjdGlvbiBmdW5jdGlvbiwgb3IgdGhlIGJvb2xlYW4gPVxuICAgKiByZXN1bHQgb2YgYSBmZWF0dXJlIGRldGVjdGlvbiBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIE1vZGVybml6clByb3RvLl90cmlnZ2VyID0gZnVuY3Rpb24oZmVhdHVyZSwgcmVzKSB7XG4gICAgaWYgKCF0aGlzLl9sW2ZlYXR1cmVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNicyA9IHRoaXMuX2xbZmVhdHVyZV07XG5cbiAgICAvLyBGb3JjZSBhc3luY1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgY2I7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgICBjYihyZXMpO1xuICAgICAgfVxuICAgIH0sIDApO1xuXG4gICAgLy8gRG9uJ3QgdHJpZ2dlciB0aGVzZSBhZ2FpblxuICAgIGRlbGV0ZSB0aGlzLl9sW2ZlYXR1cmVdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBhZGRUZXN0IGFsbG93cyB5b3UgdG8gZGVmaW5lIHlvdXIgb3duIGZlYXR1cmUgZGV0ZWN0cyB0aGF0IGFyZSBub3QgY3VycmVudGx5XG4gICAqIGluY2x1ZGVkIGluIE1vZGVybml6ciAodW5kZXIgdGhlIGNvdmVycyBpdCdzIHRoZSBleGFjdCBzYW1lIGNvZGUgTW9kZXJuaXpyXG4gICAqIHVzZXMgZm9yIGl0cyBvd24gW2ZlYXR1cmUgZGV0ZWN0aW9uc10oaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvdHJlZS9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzKSkuXG4gICAqIEp1c3QgbGlrZSB0aGUgb2ZmaWNpYWwgZGV0ZWN0cywgdGhlIHJlc3VsdFxuICAgKiB3aWxsIGJlIGFkZGVkIG9udG8gdGhlIE1vZGVybml6ciBvYmplY3QsIGFzIHdlbGwgYXMgYW4gYXBwcm9wcmlhdGUgY2xhc3NOYW1lIHNldCBvblxuICAgKiB0aGUgaHRtbCBlbGVtZW50IHdoZW4gY29uZmlndXJlZCB0byBkbyBzb1xuICAgKlxuICAgKiBAbWVtYmVyT2YgTW9kZXJuaXpyXG4gICAqIEBuYW1lIE1vZGVybml6ci5hZGRUZXN0XG4gICAqIEBvcHRpb25OYW1lIE1vZGVybml6ci5hZGRUZXN0KClcbiAgICogQG9wdGlvblByb3AgYWRkVGVzdFxuICAgKiBAYWNjZXNzIHB1YmxpY1xuICAgKiBAZnVuY3Rpb24gYWRkVGVzdFxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZlYXR1cmUgLSBUaGUgc3RyaW5nIG5hbWUgb2YgdGhlIGZlYXR1cmUgZGV0ZWN0LCBvciBhblxuICAgKiBvYmplY3Qgb2YgZmVhdHVyZSBkZXRlY3QgbmFtZXMgYW5kIHRlc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxib29sZWFufSB0ZXN0IC0gRnVuY3Rpb24gcmV0dXJuaW5nIHRydWUgaWYgZmVhdHVyZSBpcyBzdXBwb3J0ZWQsXG4gICAqIGZhbHNlIGlmIG5vdC4gT3RoZXJ3aXNlIGEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdHMgb2YgYSBmZWF0dXJlIGRldGVjdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgTW9kZXJuaXpyIG9iamVjdCB0byBhbGxvdyBjaGFpbmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBUaGUgbW9zdCBjb21tb24gd2F5IG9mIGNyZWF0aW5nIHlvdXIgb3duIGZlYXR1cmUgZGV0ZWN0cyBpcyBieSBjYWxsaW5nXG4gICAqIGBNb2Rlcm5penIuYWRkVGVzdGAgd2l0aCBhIHN0cmluZyAocHJlZmVyYWJseSBqdXN0IGxvd2VyY2FzZSwgd2l0aG91dCBhbnlcbiAgICogcHVuY3R1YXRpb24pLCBhbmQgYSBmdW5jdGlvbiB5b3Ugd2FudCBleGVjdXRlZCB0aGF0IHdpbGwgcmV0dXJuIGEgYm9vbGVhbiByZXN1bHRcbiAgICpcbiAgICogYGBganNcbiAgICogTW9kZXJuaXpyLmFkZFRlc3QoJ2l0c1R1ZXNkYXknLCBmdW5jdGlvbigpIHtcbiAgICogIHZhciBkID0gbmV3IERhdGUoKTtcbiAgICogIHJldHVybiBkLmdldERheSgpID09PSAyO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFdoZW4gdGhlIGFib3ZlIGlzIHJ1biwgaXQgd2lsbCBzZXQgTW9kZXJuaXpyLml0c3R1ZXNkYXkgdG8gYHRydWVgIHdoZW4gaXQgaXMgdHVlc2RheSxcbiAgICogYW5kIHRvIGBmYWxzZWAgZXZlcnkgb3RoZXIgZGF5IG9mIHRoZSB3ZWVrLiBPbmUgdGhpbmcgdG8gbm90aWNlIGlzIHRoYXQgdGhlIG5hbWVzIG9mXG4gICAqIGZlYXR1cmUgZGV0ZWN0IGZ1bmN0aW9ucyBhcmUgYWx3YXlzIGxvd2VyY2FzZWQgd2hlbiBhZGRlZCB0byB0aGUgTW9kZXJuaXpyIG9iamVjdC4gVGhhdFxuICAgKiBtZWFucyB0aGF0IGBNb2Rlcm5penIuaXRzVHVlc2RheWAgd2lsbCBub3QgZXhpc3QsIGJ1dCBgTW9kZXJuaXpyLml0c3R1ZXNkYXlgIHdpbGwuXG4gICAqXG4gICAqXG4gICAqICBTaW5jZSB3ZSBvbmx5IGxvb2sgYXQgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gYW55IGZlYXR1cmUgZGV0ZWN0aW9uIGZ1bmN0aW9uLFxuICAgKiAgeW91IGRvIG5vdCBuZWVkIHRvIGFjdHVhbGx5IHVzZSBhIGZ1bmN0aW9uLiBGb3Igc2ltcGxlIGRldGVjdGlvbnMsIGp1c3QgcGFzc2luZ1xuICAgKiAgaW4gYSBzdGF0ZW1lbnQgdGhhdCB3aWxsIHJldHVybiBhIGJvb2xlYW4gdmFsdWUgd29ya3MganVzdCBmaW5lLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBNb2Rlcm5penIuYWRkVGVzdCgnaGFzanF1ZXJ5JywgJ2pRdWVyeScgaW4gd2luZG93KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEp1c3QgbGlrZSBiZWZvcmUsIHdoZW4gdGhlIGFib3ZlIHJ1bnMgYE1vZGVybml6ci5oYXNqcXVlcnlgIHdpbGwgYmUgdHJ1ZSBpZlxuICAgKiBqUXVlcnkgaGFzIGJlZW4gaW5jbHVkZWQgb24gdGhlIHBhZ2UuIE5vdCB1c2luZyBhIGZ1bmN0aW9uIHNhdmVzIGEgc21hbGwgYW1vdW50XG4gICAqIG9mIG92ZXJoZWFkIGZvciB0aGUgYnJvd3NlciwgYXMgd2VsbCBhcyBtYWtpbmcgeW91ciBjb2RlIG11Y2ggbW9yZSByZWFkYWJsZS5cbiAgICpcbiAgICogRmluYWxseSwgeW91IGFsc28gaGF2ZSB0aGUgYWJpbGl0eSB0byBwYXNzIGluIGFuIG9iamVjdCBvZiBmZWF0dXJlIG5hbWVzIGFuZFxuICAgKiB0aGVpciB0ZXN0cy4gVGhpcyBpcyBoYW5keSBpZiB5b3Ugd2FudCB0byBhZGQgbXVsdGlwbGUgZGV0ZWN0aW9ucyBpbiBvbmUgZ28uXG4gICAqIFRoZSBrZXlzIHNob3VsZCBhbHdheXMgYmUgYSBzdHJpbmcsIGFuZCB0aGUgdmFsdWUgY2FuIGJlIGVpdGhlciBhIGJvb2xlYW4gb3JcbiAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYm9vbGVhbi5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGRldGVjdHMgPSB7XG4gICAqICAnaGFzanF1ZXJ5JzogJ2pRdWVyeScgaW4gd2luZG93LFxuICAgKiAgJ2l0c3R1ZXNkYXknOiBmdW5jdGlvbigpIHtcbiAgICogICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgKiAgICByZXR1cm4gZC5nZXREYXkoKSA9PT0gMjtcbiAgICogIH1cbiAgICogfVxuICAgKlxuICAgKiBNb2Rlcm5penIuYWRkVGVzdChkZXRlY3RzKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRoZXJlIGlzIHJlYWxseSBubyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGZpcnN0IG1ldGhvZHMgYW5kIHRoaXMgb25lLCBpdCBpc1xuICAgKiBqdXN0IGEgY29udmVuaWVuY2UgdG8gbGV0IHlvdSB3cml0ZSBtb3JlIHJlYWRhYmxlIGNvZGUuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRUZXN0KGZlYXR1cmUsIHRlc3QpIHtcblxuICAgIGlmICh0eXBlb2YgZmVhdHVyZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBmZWF0dXJlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGZlYXR1cmUsIGtleSkpIHtcbiAgICAgICAgICBhZGRUZXN0KGtleSwgZmVhdHVyZVsga2V5IF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcblxuICAgICAgZmVhdHVyZSA9IGZlYXR1cmUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBmZWF0dXJlTmFtZVNwbGl0ID0gZmVhdHVyZS5zcGxpdCgnLicpO1xuICAgICAgdmFyIGxhc3QgPSBNb2Rlcm5penJbZmVhdHVyZU5hbWVTcGxpdFswXV07XG5cbiAgICAgIC8vIEFnYWluLCB3ZSBkb24ndCBjaGVjayBmb3IgcGFyZW50IHRlc3QgZXhpc3RlbmNlLiBHZXQgdGhhdCByaWdodCwgdGhvdWdoLlxuICAgICAgaWYgKGZlYXR1cmVOYW1lU3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGxhc3QgPSBsYXN0W2ZlYXR1cmVOYW1lU3BsaXRbMV1dO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxhc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHdlJ3JlIGdvaW5nIHRvIHF1aXQgaWYgeW91J3JlIHRyeWluZyB0byBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgdGVzdFxuICAgICAgICAvLyBpZiB3ZSB3ZXJlIHRvIGFsbG93IGl0LCB3ZSdkIGRvIHRoaXM6XG4gICAgICAgIC8vICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIlxcXFxiKG5vLSk/XCIgKyBmZWF0dXJlICsgXCJcXFxcYlwiKTtcbiAgICAgICAgLy8gICBkb2NFbGVtZW50LmNsYXNzTmFtZSA9IGRvY0VsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoIHJlLCAnJyApO1xuICAgICAgICAvLyBidXQsIG5vIHJseSwgc3R1ZmYgJ2VtLlxuICAgICAgICByZXR1cm4gTW9kZXJuaXpyO1xuICAgICAgfVxuXG4gICAgICB0ZXN0ID0gdHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbicgPyB0ZXN0KCkgOiB0ZXN0O1xuXG4gICAgICAvLyBTZXQgdGhlIHZhbHVlICh0aGlzIGlzIHRoZSBtYWdpYywgcmlnaHQgaGVyZSkuXG4gICAgICBpZiAoZmVhdHVyZU5hbWVTcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgTW9kZXJuaXpyW2ZlYXR1cmVOYW1lU3BsaXRbMF1dID0gdGVzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhc3QgdG8gYSBCb29sZWFuLCBpZiBub3Qgb25lIGFscmVhZHlcbiAgICAgICAgaWYgKE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSAmJiAhKE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSBpbnN0YW5jZW9mIEJvb2xlYW4pKSB7XG4gICAgICAgICAgTW9kZXJuaXpyW2ZlYXR1cmVOYW1lU3BsaXRbMF1dID0gbmV3IEJvb2xlYW4oTW9kZXJuaXpyW2ZlYXR1cmVOYW1lU3BsaXRbMF1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXVtmZWF0dXJlTmFtZVNwbGl0WzFdXSA9IHRlc3Q7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBhIHNpbmdsZSBjbGFzcyAoZWl0aGVyIGBmZWF0dXJlYCBvciBgbm8tZmVhdHVyZWApXG4gICAgICBzZXRDbGFzc2VzKFsoISF0ZXN0ICYmIHRlc3QgIT09IGZhbHNlID8gJycgOiAnbm8tJykgKyBmZWF0dXJlTmFtZVNwbGl0LmpvaW4oJy0nKV0pO1xuXG4gICAgICAvLyBUcmlnZ2VyIHRoZSBldmVudFxuICAgICAgTW9kZXJuaXpyLl90cmlnZ2VyKGZlYXR1cmUsIHRlc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBNb2Rlcm5penI7IC8vIGFsbG93IGNoYWluaW5nLlxuICB9XG5cbiAgLy8gQWZ0ZXIgYWxsIHRoZSB0ZXN0cyBhcmUgcnVuLCBhZGQgc2VsZiB0byB0aGUgTW9kZXJuaXpyIHByb3RvdHlwZVxuICBNb2Rlcm5penIuX3EucHVzaChmdW5jdGlvbigpIHtcbiAgICBNb2Rlcm5penJQcm90by5hZGRUZXN0ID0gYWRkVGVzdDtcbiAgfSk7XG5cbiAgXG5cblxuICAvKipcbiAgICogQG9wdGlvbk5hbWUgaHRtbDVwcmludHNoaXZcbiAgICogQG9wdGlvblByb3AgaHRtbDVwcmludHNoaXZcbiAgICovXG5cbiAgLy8gVGFrZSB0aGUgaHRtbDUgdmFyaWFibGUgb3V0IG9mIHRoZSBodG1sNXNoaXYgc2NvcGUgc28gd2UgY2FuIHJldHVybiBpdC5cbiAgdmFyIGh0bWw1O1xuICBpZiAoIWlzU1ZHKSB7XG4gICAgLyoqXG4gICAgICogQHByZXNlcnZlIEhUTUw1IFNoaXYgMy43LjMgfCBAYWZhcmthcyBAamRhbHRvbiBAam9uX25lYWwgQHJlbSB8IE1JVC9HUEwyIExpY2Vuc2VkXG4gICAgICovXG4gICAgOyhmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50KSB7XG4gICAgICAvKmpzaGludCBldmlsOnRydWUgKi9cbiAgICAgIC8qKiB2ZXJzaW9uICovXG4gICAgICB2YXIgdmVyc2lvbiA9ICczLjcuMyc7XG5cbiAgICAgIC8qKiBQcmVzZXQgb3B0aW9ucyAqL1xuICAgICAgdmFyIG9wdGlvbnMgPSB3aW5kb3cuaHRtbDUgfHwge307XG5cbiAgICAgIC8qKiBVc2VkIHRvIHNraXAgcHJvYmxlbSBlbGVtZW50cyAqL1xuICAgICAgdmFyIHJlU2tpcCA9IC9ePHxeKD86YnV0dG9ufG1hcHxzZWxlY3R8dGV4dGFyZWF8b2JqZWN0fGlmcmFtZXxvcHRpb258b3B0Z3JvdXApJC9pO1xuXG4gICAgICAvKiogTm90IGFsbCBlbGVtZW50cyBjYW4gYmUgY2xvbmVkIGluIElFICoqL1xuICAgICAgdmFyIHNhdmVDbG9uZXMgPSAvXig/OmF8Ynxjb2RlfGRpdnxmaWVsZHNldHxoMXxoMnxoM3xoNHxoNXxoNnxpfGxhYmVsfGxpfG9sfHB8cXxzcGFufHN0cm9uZ3xzdHlsZXx0YWJsZXx0Ym9keXx0ZHx0aHx0cnx1bCkkL2k7XG5cbiAgICAgIC8qKiBEZXRlY3Qgd2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyBkZWZhdWx0IGh0bWw1IHN0eWxlcyAqL1xuICAgICAgdmFyIHN1cHBvcnRzSHRtbDVTdHlsZXM7XG5cbiAgICAgIC8qKiBOYW1lIG9mIHRoZSBleHBhbmRvLCB0byB3b3JrIHdpdGggbXVsdGlwbGUgZG9jdW1lbnRzIG9yIHRvIHJlLXNoaXYgb25lIGRvY3VtZW50ICovXG4gICAgICB2YXIgZXhwYW5kbyA9ICdfaHRtbDVzaGl2JztcblxuICAgICAgLyoqIFRoZSBpZCBmb3IgdGhlIHRoZSBkb2N1bWVudHMgZXhwYW5kbyAqL1xuICAgICAgdmFyIGV4cGFuSUQgPSAwO1xuXG4gICAgICAvKiogQ2FjaGVkIGRhdGEgZm9yIGVhY2ggZG9jdW1lbnQgKi9cbiAgICAgIHZhciBleHBhbmRvRGF0YSA9IHt9O1xuXG4gICAgICAvKiogRGV0ZWN0IHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdW5rbm93biBlbGVtZW50cyAqL1xuICAgICAgdmFyIHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzO1xuXG4gICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgYS5pbm5lckhUTUwgPSAnPHh5ej48L3h5ej4nO1xuICAgICAgICAgIC8vaWYgdGhlIGhpZGRlbiBwcm9wZXJ0eSBpcyBpbXBsZW1lbnRlZCB3ZSBjYW4gYXNzdW1lLCB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIGJhc2ljIEhUTUw1IFN0eWxlc1xuICAgICAgICAgIHN1cHBvcnRzSHRtbDVTdHlsZXMgPSAoJ2hpZGRlbicgaW4gYSk7XG5cbiAgICAgICAgICBzdXBwb3J0c1Vua25vd25FbGVtZW50cyA9IGEuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSB8fCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBhc3NpZ24gYSBmYWxzZSBwb3NpdGl2ZSBpZiB1bmFibGUgdG8gc2hpdlxuICAgICAgICAgICAgKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpKCdhJyk7XG4gICAgICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBmcmFnLmNsb25lTm9kZSA9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICB0eXBlb2YgZnJhZy5jcmVhdGVEb2N1bWVudEZyYWdtZW50ID09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICAgIHR5cGVvZiBmcmFnLmNyZWF0ZUVsZW1lbnQgPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSgpKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgLy8gYXNzaWduIGEgZmFsc2UgcG9zaXRpdmUgaWYgZGV0ZWN0aW9uIGZhaWxzID0+IHVuYWJsZSB0byBzaGl2XG4gICAgICAgICAgc3VwcG9ydHNIdG1sNVN0eWxlcyA9IHRydWU7XG4gICAgICAgICAgc3VwcG9ydHNVbmtub3duRWxlbWVudHMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIH0oKSk7XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBzdHlsZSBzaGVldCB3aXRoIHRoZSBnaXZlbiBDU1MgdGV4dCBhbmQgYWRkcyBpdCB0byB0aGUgZG9jdW1lbnQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgZG9jdW1lbnQuXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY3NzVGV4dCBUaGUgQ1NTIHRleHQuXG4gICAgICAgKiBAcmV0dXJucyB7U3R5bGVTaGVldH0gVGhlIHN0eWxlIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGFkZFN0eWxlU2hlZXQob3duZXJEb2N1bWVudCwgY3NzVGV4dCkge1xuICAgICAgICB2YXIgcCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpLFxuICAgICAgICAgIHBhcmVudCA9IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSB8fCBvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICBwLmlubmVySFRNTCA9ICd4PHN0eWxlPicgKyBjc3NUZXh0ICsgJzwvc3R5bGU+JztcbiAgICAgICAgcmV0dXJuIHBhcmVudC5pbnNlcnRCZWZvcmUocC5sYXN0Q2hpbGQsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBgaHRtbDUuZWxlbWVudHNgIGFzIGFuIGFycmF5LlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2Ygc2hpdmVkIGVsZW1lbnQgbm9kZSBuYW1lcy5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZ2V0RWxlbWVudHMoKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGh0bWw1LmVsZW1lbnRzO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnRzID09ICdzdHJpbmcnID8gZWxlbWVudHMuc3BsaXQoJyAnKSA6IGVsZW1lbnRzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEV4dGVuZHMgdGhlIGJ1aWx0LWluIGxpc3Qgb2YgaHRtbDUgZWxlbWVudHNcbiAgICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IG5ld0VsZW1lbnRzIHdoaXRlc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb3IgYXJyYXkgb2YgbmV3IGVsZW1lbnQgbmFtZXMgdG8gc2hpdlxuICAgICAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgY29udGV4dCBkb2N1bWVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gYWRkRWxlbWVudHMobmV3RWxlbWVudHMsIG93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gaHRtbDUuZWxlbWVudHM7XG4gICAgICAgIGlmKHR5cGVvZiBlbGVtZW50cyAhPSAnc3RyaW5nJyl7XG4gICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mIG5ld0VsZW1lbnRzICE9ICdzdHJpbmcnKXtcbiAgICAgICAgICBuZXdFbGVtZW50cyA9IG5ld0VsZW1lbnRzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBodG1sNS5lbGVtZW50cyA9IGVsZW1lbnRzICsnICcrIG5ld0VsZW1lbnRzO1xuICAgICAgICBzaGl2RG9jdW1lbnQob3duZXJEb2N1bWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgZGF0YSBhc3NvY2lhdGVkIHRvIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50LlxuICAgICAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IG9mIGRhdGEuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBleHBhbmRvRGF0YVtvd25lckRvY3VtZW50W2V4cGFuZG9dXTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgIGV4cGFuSUQrKztcbiAgICAgICAgICBvd25lckRvY3VtZW50W2V4cGFuZG9dID0gZXhwYW5JRDtcbiAgICAgICAgICBleHBhbmRvRGF0YVtleHBhbklEXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0dXJucyBhIHNoaXZlZCBlbGVtZW50IGZvciB0aGUgZ2l2ZW4gbm9kZU5hbWUgYW5kIGRvY3VtZW50XG4gICAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZSBuYW1lIG9mIHRoZSBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBjb250ZXh0IGRvY3VtZW50LlxuICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHNoaXZlZCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KG5vZGVOYW1lLCBvd25lckRvY3VtZW50LCBkYXRhKXtcbiAgICAgICAgaWYgKCFvd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgb3duZXJEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmKHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzKXtcbiAgICAgICAgICByZXR1cm4gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gZ2V0RXhwYW5kb0RhdGEob3duZXJEb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGU7XG5cbiAgICAgICAgaWYgKGRhdGEuY2FjaGVbbm9kZU5hbWVdKSB7XG4gICAgICAgICAgbm9kZSA9IGRhdGEuY2FjaGVbbm9kZU5hbWVdLmNsb25lTm9kZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHNhdmVDbG9uZXMudGVzdChub2RlTmFtZSkpIHtcbiAgICAgICAgICBub2RlID0gKGRhdGEuY2FjaGVbbm9kZU5hbWVdID0gZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKSkuY2xvbmVOb2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IGRhdGEuY3JlYXRlRWxlbShub2RlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdm9pZCBhZGRpbmcgc29tZSBlbGVtZW50cyB0byBmcmFnbWVudHMgaW4gSUUgPCA5IGJlY2F1c2VcbiAgICAgICAgLy8gKiBBdHRyaWJ1dGVzIGxpa2UgYG5hbWVgIG9yIGB0eXBlYCBjYW5ub3QgYmUgc2V0L2NoYW5nZWQgb25jZSBhbiBlbGVtZW50XG4gICAgICAgIC8vICAgaXMgaW5zZXJ0ZWQgaW50byBhIGRvY3VtZW50L2ZyYWdtZW50XG4gICAgICAgIC8vICogTGluayBlbGVtZW50cyB3aXRoIGBzcmNgIGF0dHJpYnV0ZXMgdGhhdCBhcmUgaW5hY2Nlc3NpYmxlLCBhcyB3aXRoXG4gICAgICAgIC8vICAgYSA0MDMgcmVzcG9uc2UsIHdpbGwgY2F1c2UgdGhlIHRhYi93aW5kb3cgdG8gY3Jhc2hcbiAgICAgICAgLy8gKiBTY3JpcHQgZWxlbWVudHMgYXBwZW5kZWQgdG8gZnJhZ21lbnRzIHdpbGwgZXhlY3V0ZSB3aGVuIHRoZWlyIGBzcmNgXG4gICAgICAgIC8vICAgb3IgYHRleHRgIHByb3BlcnR5IGlzIHNldFxuICAgICAgICByZXR1cm4gbm9kZS5jYW5IYXZlQ2hpbGRyZW4gJiYgIXJlU2tpcC50ZXN0KG5vZGVOYW1lKSAmJiAhbm9kZS50YWdVcm4gPyBkYXRhLmZyYWcuYXBwZW5kQ2hpbGQobm9kZSkgOiBub2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJldHVybnMgYSBzaGl2ZWQgRG9jdW1lbnRGcmFnbWVudCBmb3IgdGhlIGdpdmVuIGRvY3VtZW50XG4gICAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGNvbnRleHQgZG9jdW1lbnQuXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2hpdmVkIERvY3VtZW50RnJhZ21lbnQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQob3duZXJEb2N1bWVudCwgZGF0YSl7XG4gICAgICAgIGlmICghb3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZihzdXBwb3J0c1Vua25vd25FbGVtZW50cyl7XG4gICAgICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpO1xuICAgICAgICB2YXIgY2xvbmUgPSBkYXRhLmZyYWcuY2xvbmVOb2RlKCksXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgZWxlbXMgPSBnZXRFbGVtZW50cygpLFxuICAgICAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XG4gICAgICAgIGZvcig7aTxsO2krKyl7XG4gICAgICAgICAgY2xvbmUuY3JlYXRlRWxlbWVudChlbGVtc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNoaXZzIHRoZSBgY3JlYXRlRWxlbWVudGAgYW5kIGBjcmVhdGVEb2N1bWVudEZyYWdtZW50YCBtZXRob2RzIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0ge0RvY3VtZW50fERvY3VtZW50RnJhZ21lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50LlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBzaGl2TWV0aG9kcyhvd25lckRvY3VtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YS5jYWNoZSkge1xuICAgICAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICAgICAgICBkYXRhLmNyZWF0ZUVsZW0gPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQ7XG4gICAgICAgICAgZGF0YS5jcmVhdGVGcmFnID0gb3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50O1xuICAgICAgICAgIGRhdGEuZnJhZyA9IGRhdGEuY3JlYXRlRnJhZygpO1xuICAgICAgICB9XG5cblxuICAgICAgICBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlTmFtZSkge1xuICAgICAgICAgIC8vYWJvcnQgc2hpdlxuICAgICAgICAgIGlmICghaHRtbDUuc2hpdk1ldGhvZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmNyZWF0ZUVsZW0obm9kZU5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChub2RlTmFtZSwgb3duZXJEb2N1bWVudCwgZGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gRnVuY3Rpb24oJ2gsZicsICdyZXR1cm4gZnVuY3Rpb24oKXsnICtcbiAgICAgICAgICAndmFyIG49Zi5jbG9uZU5vZGUoKSxjPW4uY3JlYXRlRWxlbWVudDsnICtcbiAgICAgICAgICAnaC5zaGl2TWV0aG9kcyYmKCcgK1xuICAgICAgICAgIC8vIHVucm9sbCB0aGUgYGNyZWF0ZUVsZW1lbnRgIGNhbGxzXG4gICAgICAgICAgZ2V0RWxlbWVudHMoKS5qb2luKCkucmVwbGFjZSgvW1xcd1xcLTpdKy9nLCBmdW5jdGlvbihub2RlTmFtZSkge1xuICAgICAgICAgICAgZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKTtcbiAgICAgICAgICAgIGRhdGEuZnJhZy5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgICAgIHJldHVybiAnYyhcIicgKyBub2RlTmFtZSArICdcIiknO1xuICAgICAgICAgIH0pICtcbiAgICAgICAgICAnKTtyZXR1cm4gbn0nXG4gICAgICAgICkoaHRtbDUsIGRhdGEuZnJhZyk7XG4gICAgICB9XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvKipcbiAgICAgICAqIFNoaXZzIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gc2hpdi5cbiAgICAgICAqIEByZXR1cm5zIHtEb2N1bWVudH0gVGhlIHNoaXZlZCBkb2N1bWVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gc2hpdkRvY3VtZW50KG93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKCFvd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgb3duZXJEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gZ2V0RXhwYW5kb0RhdGEob3duZXJEb2N1bWVudCk7XG5cbiAgICAgICAgaWYgKGh0bWw1LnNoaXZDU1MgJiYgIXN1cHBvcnRzSHRtbDVTdHlsZXMgJiYgIWRhdGEuaGFzQ1NTKSB7XG4gICAgICAgICAgZGF0YS5oYXNDU1MgPSAhIWFkZFN0eWxlU2hlZXQob3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIC8vIGNvcnJlY3RzIGJsb2NrIGRpc3BsYXkgbm90IGRlZmluZWQgaW4gSUU2LzcvOC85XG4gICAgICAgICAgICAnYXJ0aWNsZSxhc2lkZSxkaWFsb2csZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsbWFpbixuYXYsc2VjdGlvbntkaXNwbGF5OmJsb2NrfScgK1xuICAgICAgICAgICAgLy8gYWRkcyBzdHlsaW5nIG5vdCBwcmVzZW50IGluIElFNi83LzgvOVxuICAgICAgICAgICAgJ21hcmt7YmFja2dyb3VuZDojRkYwO2NvbG9yOiMwMDB9JyArXG4gICAgICAgICAgICAvLyBoaWRlcyBub24tcmVuZGVyZWQgZWxlbWVudHNcbiAgICAgICAgICAgICd0ZW1wbGF0ZXtkaXNwbGF5Om5vbmV9J1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdXBwb3J0c1Vua25vd25FbGVtZW50cykge1xuICAgICAgICAgIHNoaXZNZXRob2RzKG93bmVyRG9jdW1lbnQsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvd25lckRvY3VtZW50O1xuICAgICAgfVxuXG4gICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgYGh0bWw1YCBvYmplY3QgaXMgZXhwb3NlZCBzbyB0aGF0IG1vcmUgZWxlbWVudHMgY2FuIGJlIHNoaXZlZCBhbmRcbiAgICAgICAqIGV4aXN0aW5nIHNoaXZpbmcgY2FuIGJlIGRldGVjdGVkIG9uIGlmcmFtZXMuXG4gICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKlxuICAgICAgICogLy8gb3B0aW9ucyBjYW4gYmUgY2hhbmdlZCBiZWZvcmUgdGhlIHNjcmlwdCBpcyBpbmNsdWRlZFxuICAgICAgICogaHRtbDUgPSB7ICdlbGVtZW50cyc6ICdtYXJrIHNlY3Rpb24nLCAnc2hpdkNTUyc6IGZhbHNlLCAnc2hpdk1ldGhvZHMnOiBmYWxzZSB9O1xuICAgICAgICovXG4gICAgICB2YXIgaHRtbDUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Ygbm9kZSBuYW1lcyBvZiB0aGUgZWxlbWVudHMgdG8gc2hpdi5cbiAgICAgICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICAgICAqIEB0eXBlIEFycmF5fFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgJ2VsZW1lbnRzJzogb3B0aW9ucy5lbGVtZW50cyB8fCAnYWJiciBhcnRpY2xlIGFzaWRlIGF1ZGlvIGJkaSBjYW52YXMgZGF0YSBkYXRhbGlzdCBkZXRhaWxzIGRpYWxvZyBmaWdjYXB0aW9uIGZpZ3VyZSBmb290ZXIgaGVhZGVyIGhncm91cCBtYWluIG1hcmsgbWV0ZXIgbmF2IG91dHB1dCBwaWN0dXJlIHByb2dyZXNzIHNlY3Rpb24gc3VtbWFyeSB0ZW1wbGF0ZSB0aW1lIHZpZGVvJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogY3VycmVudCB2ZXJzaW9uIG9mIGh0bWw1c2hpdlxuICAgICAgICAgKi9cbiAgICAgICAgJ3ZlcnNpb24nOiB2ZXJzaW9uLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgSFRNTDUgc3R5bGUgc2hlZXQgc2hvdWxkIGJlIGluc2VydGVkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgJ3NoaXZDU1MnOiAob3B0aW9ucy5zaGl2Q1NTICE9PSBmYWxzZSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIGVxdWFsIHRvIHRydWUgaWYgYSBicm93c2VyIHN1cHBvcnRzIGNyZWF0aW5nIHVua25vd24vSFRNTDUgZWxlbWVudHNcbiAgICAgICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgICdzdXBwb3J0c1Vua25vd25FbGVtZW50cyc6IHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgZG9jdW1lbnQncyBgY3JlYXRlRWxlbWVudGAgYW5kIGBjcmVhdGVEb2N1bWVudEZyYWdtZW50YFxuICAgICAgICAgKiBtZXRob2RzIHNob3VsZCBiZSBvdmVyd3JpdHRlbi5cbiAgICAgICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgICdzaGl2TWV0aG9kcyc6IChvcHRpb25zLnNoaXZNZXRob2RzICE9PSBmYWxzZSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3RyaW5nIHRvIGRlc2NyaWJlIHRoZSB0eXBlIG9mIGBodG1sNWAgb2JqZWN0IChcImRlZmF1bHRcIiBvciBcImRlZmF1bHQgcHJpbnRcIikuXG4gICAgICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgICd0eXBlJzogJ2RlZmF1bHQnLFxuXG4gICAgICAgIC8vIHNoaXZzIHRoZSBkb2N1bWVudCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBgaHRtbDVgIG9iamVjdCBvcHRpb25zXG4gICAgICAgICdzaGl2RG9jdW1lbnQnOiBzaGl2RG9jdW1lbnQsXG5cbiAgICAgICAgLy9jcmVhdGVzIGEgc2hpdmVkIGVsZW1lbnRcbiAgICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcblxuICAgICAgICAvL2NyZWF0ZXMgYSBzaGl2ZWQgZG9jdW1lbnRGcmFnbWVudFxuICAgICAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50OiBjcmVhdGVEb2N1bWVudEZyYWdtZW50LFxuXG4gICAgICAgIC8vZXh0ZW5kcyBsaXN0IG9mIGVsZW1lbnRzXG4gICAgICAgIGFkZEVsZW1lbnRzOiBhZGRFbGVtZW50c1xuICAgICAgfTtcblxuICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgIC8vIGV4cG9zZSBodG1sNVxuICAgICAgd2luZG93Lmh0bWw1ID0gaHRtbDU7XG5cbiAgICAgIC8vIHNoaXYgdGhlIGRvY3VtZW50XG4gICAgICBzaGl2RG9jdW1lbnQoZG9jdW1lbnQpO1xuXG4gICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUHJpbnQgU2hpdiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgLyoqIFVzZWQgdG8gZmlsdGVyIG1lZGlhIHR5cGVzICovXG4gICAgICB2YXIgcmVNZWRpYSA9IC9eJHxcXGIoPzphbGx8cHJpbnQpXFxiLztcblxuICAgICAgLyoqIFVzZWQgdG8gbmFtZXNwYWNlIHByaW50YWJsZSBlbGVtZW50cyAqL1xuICAgICAgdmFyIHNoaXZOYW1lc3BhY2UgPSAnaHRtbDVzaGl2JztcblxuICAgICAgLyoqIERldGVjdCB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHNoaXZhYmxlIHN0eWxlIHNoZWV0cyAqL1xuICAgICAgdmFyIHN1cHBvcnRzU2hpdmFibGVTaGVldHMgPSAhc3VwcG9ydHNVbmtub3duRWxlbWVudHMgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBhc3NpZ24gYSBmYWxzZSBuZWdhdGl2ZSBpZiB1bmFibGUgdG8gc2hpdlxuICAgICAgICB2YXIgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiAhKFxuICAgICAgICAgIHR5cGVvZiBkb2N1bWVudC5uYW1lc3BhY2VzID09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgdHlwZW9mIGRvY3VtZW50LnBhcmVudFdpbmRvdyA9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgIHR5cGVvZiBkb2NFbC5hcHBseUVsZW1lbnQgPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICB0eXBlb2YgZG9jRWwucmVtb3ZlTm9kZSA9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYXR0YWNoRXZlbnQgPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgKTtcbiAgICAgIH0oKSk7XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvKipcbiAgICAgICAqIFdyYXBzIGFsbCBIVE1MNSBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gZG9jdW1lbnQgd2l0aCBwcmludGFibGUgZWxlbWVudHMuXG4gICAgICAgKiAoZWcuIHRoZSBcImhlYWRlclwiIGVsZW1lbnQgaXMgd3JhcHBlZCB3aXRoIHRoZSBcImh0bWw1c2hpdjpoZWFkZXJcIiBlbGVtZW50KVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50LlxuICAgICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSB3cmFwcGVycyBhZGRlZC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gYWRkV3JhcHBlcnMob3duZXJEb2N1bWVudCkge1xuICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICBub2RlcyA9IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSxcbiAgICAgICAgICBpbmRleCA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICByZUVsZW1lbnRzID0gUmVnRXhwKCdeKD86JyArIGdldEVsZW1lbnRzKCkuam9pbignfCcpICsgJykkJywgJ2knKSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tpbmRleF07XG4gICAgICAgICAgaWYgKHJlRWxlbWVudHMudGVzdChub2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5hcHBseUVsZW1lbnQoY3JlYXRlV3JhcHBlcihub2RlKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBwcmludGFibGUgd3JhcHBlciBmb3IgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50LlxuICAgICAgICogQHJldHVybnMge0VsZW1lbnR9IFRoZSB3cmFwcGVyLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG5vZGUsXG4gICAgICAgICAgbm9kZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXMsXG4gICAgICAgICAgaW5kZXggPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgICAgd3JhcHBlciA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHNoaXZOYW1lc3BhY2UgKyAnOicgKyBlbGVtZW50Lm5vZGVOYW1lKTtcblxuICAgICAgICAvLyBjb3B5IGVsZW1lbnQgYXR0cmlidXRlcyB0byB0aGUgd3JhcHBlclxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tpbmRleF07XG4gICAgICAgICAgbm9kZS5zcGVjaWZpZWQgJiYgd3JhcHBlci5zZXRBdHRyaWJ1dGUobm9kZS5ub2RlTmFtZSwgbm9kZS5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgZWxlbWVudCBzdHlsZXMgdG8gdGhlIHdyYXBwZXJcbiAgICAgICAgd3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gZWxlbWVudC5zdHlsZS5jc3NUZXh0O1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTaGl2cyB0aGUgZ2l2ZW4gQ1NTIHRleHQuXG4gICAgICAgKiAoZWcuIGhlYWRlcnt9IGJlY29tZXMgaHRtbDVzaGl2XFw6aGVhZGVye30pXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGNzc1RleHQgVGhlIENTUyB0ZXh0IHRvIHNoaXYuXG4gICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc2hpdmVkIENTUyB0ZXh0LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBzaGl2Q3NzVGV4dChjc3NUZXh0KSB7XG4gICAgICAgIHZhciBwYWlyLFxuICAgICAgICAgIHBhcnRzID0gY3NzVGV4dC5zcGxpdCgneycpLFxuICAgICAgICAgIGluZGV4ID0gcGFydHMubGVuZ3RoLFxuICAgICAgICAgIHJlRWxlbWVudHMgPSBSZWdFeHAoJyhefFtcXFxccyw+K35dKSgnICsgZ2V0RWxlbWVudHMoKS5qb2luKCd8JykgKyAnKSg/PVtbXFxcXHMsPit+Iy46XXwkKScsICdnaScpLFxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gJyQxJyArIHNoaXZOYW1lc3BhY2UgKyAnXFxcXDokMic7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBwYWlyID0gcGFydHNbaW5kZXhdID0gcGFydHNbaW5kZXhdLnNwbGl0KCd9Jyk7XG4gICAgICAgICAgcGFpcltwYWlyLmxlbmd0aCAtIDFdID0gcGFpcltwYWlyLmxlbmd0aCAtIDFdLnJlcGxhY2UocmVFbGVtZW50cywgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgIHBhcnRzW2luZGV4XSA9IHBhaXIuam9pbignfScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCd7Jyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gd3JhcHBlcnMsIGxlYXZpbmcgdGhlIG9yaWdpbmFsIGVsZW1lbnRzLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbXMge0FycmF5fSB3cmFwcGVycyBBbiBhcnJheSBvZiBwcmludGFibGUgd3JhcHBlcnMuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZVdyYXBwZXJzKHdyYXBwZXJzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHdyYXBwZXJzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB3cmFwcGVyc1tpbmRleF0ucmVtb3ZlTm9kZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvKipcbiAgICAgICAqIFNoaXZzIHRoZSBnaXZlbiBkb2N1bWVudCBmb3IgcHJpbnQuXG4gICAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHNoaXYuXG4gICAgICAgKiBAcmV0dXJucyB7RG9jdW1lbnR9IFRoZSBzaGl2ZWQgZG9jdW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHNoaXZQcmludChvd25lckRvY3VtZW50KSB7XG4gICAgICAgIHZhciBzaGl2ZWRTaGVldCxcbiAgICAgICAgICB3cmFwcGVycyxcbiAgICAgICAgICBkYXRhID0gZ2V0RXhwYW5kb0RhdGEob3duZXJEb2N1bWVudCksXG4gICAgICAgICAgbmFtZXNwYWNlcyA9IG93bmVyRG9jdW1lbnQubmFtZXNwYWNlcyxcbiAgICAgICAgICBvd25lcldpbmRvdyA9IG93bmVyRG9jdW1lbnQucGFyZW50V2luZG93O1xuXG4gICAgICAgIGlmICghc3VwcG9ydHNTaGl2YWJsZVNoZWV0cyB8fCBvd25lckRvY3VtZW50LnByaW50U2hpdmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lc3BhY2VzW3NoaXZOYW1lc3BhY2VdID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbmFtZXNwYWNlcy5hZGQoc2hpdk5hbWVzcGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVTaGVldCgpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoZGF0YS5fcmVtb3ZlU2hlZXRUaW1lcik7XG4gICAgICAgICAgaWYgKHNoaXZlZFNoZWV0KSB7XG4gICAgICAgICAgICBzaGl2ZWRTaGVldC5yZW1vdmVOb2RlKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaGl2ZWRTaGVldD0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG93bmVyV2luZG93LmF0dGFjaEV2ZW50KCdvbmJlZm9yZXByaW50JywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICByZW1vdmVTaGVldCgpO1xuXG4gICAgICAgICAgdmFyIGltcG9ydHMsXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICBzaGVldCxcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBvd25lckRvY3VtZW50LnN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgY3NzVGV4dCA9IFtdLFxuICAgICAgICAgICAgaW5kZXggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgIHNoZWV0cyA9IEFycmF5KGluZGV4KTtcblxuICAgICAgICAgIC8vIGNvbnZlcnQgc3R5bGVTaGVldHMgY29sbGVjdGlvbiB0byBhbiBhcnJheVxuICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICBzaGVldHNbaW5kZXhdID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbmNhdCBhbGwgc3R5bGUgc2hlZXQgQ1NTIHRleHRcbiAgICAgICAgICB3aGlsZSAoKHNoZWV0ID0gc2hlZXRzLnBvcCgpKSkge1xuICAgICAgICAgICAgLy8gSUUgZG9lcyBub3QgZW5mb3JjZSBhIHNhbWUgb3JpZ2luIHBvbGljeSBmb3IgZXh0ZXJuYWwgc3R5bGUgc2hlZXRzLi4uXG4gICAgICAgICAgICAvLyBidXQgaGFzIHRyb3VibGUgd2l0aCBzb21lIGR5bmFtaWNhbGx5IGNyZWF0ZWQgc3R5bGVzaGVldHNcbiAgICAgICAgICAgIGlmICghc2hlZXQuZGlzYWJsZWQgJiYgcmVNZWRpYS50ZXN0KHNoZWV0Lm1lZGlhKSkge1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0cyA9IHNoZWV0LmltcG9ydHM7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gaW1wb3J0cy5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gY2F0Y2goZXIpe1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBzaGVldHMucHVzaChpbXBvcnRzW2luZGV4XSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNzc1RleHQucHVzaChzaGVldC5jc3NUZXh0KTtcbiAgICAgICAgICAgICAgfSBjYXRjaChlcil7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHdyYXAgYWxsIEhUTUw1IGVsZW1lbnRzIHdpdGggcHJpbnRhYmxlIGVsZW1lbnRzIGFuZCBhZGQgdGhlIHNoaXZlZCBzdHlsZSBzaGVldFxuICAgICAgICAgIGNzc1RleHQgPSBzaGl2Q3NzVGV4dChjc3NUZXh0LnJldmVyc2UoKS5qb2luKCcnKSk7XG4gICAgICAgICAgd3JhcHBlcnMgPSBhZGRXcmFwcGVycyhvd25lckRvY3VtZW50KTtcbiAgICAgICAgICBzaGl2ZWRTaGVldCA9IGFkZFN0eWxlU2hlZXQob3duZXJEb2N1bWVudCwgY3NzVGV4dCk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgb3duZXJXaW5kb3cuYXR0YWNoRXZlbnQoJ29uYWZ0ZXJwcmludCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHJlbW92ZSB3cmFwcGVycywgbGVhdmluZyB0aGUgb3JpZ2luYWwgZWxlbWVudHMsIGFuZCByZW1vdmUgdGhlIHNoaXZlZCBzdHlsZSBzaGVldFxuICAgICAgICAgIHJlbW92ZVdyYXBwZXJzKHdyYXBwZXJzKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoZGF0YS5fcmVtb3ZlU2hlZXRUaW1lcik7XG4gICAgICAgICAgZGF0YS5fcmVtb3ZlU2hlZXRUaW1lciA9IHNldFRpbWVvdXQocmVtb3ZlU2hlZXQsIDUwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG93bmVyRG9jdW1lbnQucHJpbnRTaGl2ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gb3duZXJEb2N1bWVudDtcbiAgICAgIH1cblxuICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgIC8vIGV4cG9zZSBBUElcbiAgICAgIGh0bWw1LnR5cGUgKz0gJyBwcmludCc7XG4gICAgICBodG1sNS5zaGl2UHJpbnQgPSBzaGl2UHJpbnQ7XG5cbiAgICAgIC8vIHNoaXYgZm9yIHByaW50XG4gICAgICBzaGl2UHJpbnQoZG9jdW1lbnQpO1xuXG4gICAgICBpZih0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKXtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBodG1sNTtcbiAgICAgIH1cblxuICAgIH0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGRvY3VtZW50KSk7XG4gIH1cblxuICA7XG5cbiAgLyoqXG4gICAqIGNvbnRhaW5zIGNoZWNrcyB0byBzZWUgaWYgYSBzdHJpbmcgY29udGFpbnMgYW5vdGhlciBzdHJpbmdcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBjb250YWluc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB3ZSB3YW50IHRvIGNoZWNrIGZvciBzdWJzdHJpbmdzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJzdHIgLSBUaGUgc3Vic3RyaW5nIHdlIHdhbnQgdG8gc2VhcmNoIHRoZSBmaXJzdCBzdHJpbmcgZm9yXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBmaXJzdCBzdHJpbmcgJ3N0cicgY29udGFpbnMgdGhlIHNlY29uZCBzdHJpbmcgJ3N1YnN0cidcbiAgICovXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgc3Vic3RyKSB7XG4gICAgcmV0dXJuICEhfignJyArIHN0cikuaW5kZXhPZihzdWJzdHIpO1xuICB9XG5cbiAgO1xuXG4gIC8qKlxuICAgKiBjcmVhdGVFbGVtZW50IGlzIGEgY29udmVuaWVuY2Ugd3JhcHBlciBhcm91bmQgZG9jdW1lbnQuY3JlYXRlRWxlbWVudC4gU2luY2Ugd2VcbiAgICogdXNlIGNyZWF0ZUVsZW1lbnQgYWxsIG92ZXIgdGhlIHBsYWNlLCB0aGlzIGFsbG93cyBmb3IgKHNsaWdodGx5KSBzbWFsbGVyIGNvZGVcbiAgICogYXMgd2VsbCBhcyBhYnN0cmFjdGluZyBhd2F5IGlzc3VlcyB3aXRoIGNyZWF0aW5nIGVsZW1lbnRzIGluIGNvbnRleHRzIG90aGVyIHRoYW5cbiAgICogSFRNTCBkb2N1bWVudHMgKGUuZy4gU1ZHIGRvY3VtZW50cykuXG4gICAqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gY3JlYXRlRWxlbWVudFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8U1ZHRWxlbWVudH0gQW4gSFRNTCBvciBTVkcgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCgpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGNhc2UgaW4gSUU3LCB3aGVyZSB0aGUgdHlwZSBvZiBjcmVhdGVFbGVtZW50IGlzIFwib2JqZWN0XCIuXG4gICAgICAvLyBGb3IgdGhpcyByZWFzb24sIHdlIGNhbm5vdCBjYWxsIGFwcGx5KCkgYXMgT2JqZWN0IGlzIG5vdCBhIEZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYXJndW1lbnRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKGlzU1ZHKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TLmNhbGwoZG9jdW1lbnQsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIGFyZ3VtZW50c1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KGRvY3VtZW50LCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIDtcblxuICAvKipcbiAgICogQ3JlYXRlIG91ciBcIm1vZGVybml6clwiIGVsZW1lbnQgdGhhdCB3ZSBkbyBtb3N0IGZlYXR1cmUgdGVzdHMgb24uXG4gICAqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKi9cbiAgdmFyIG1vZEVsZW0gPSB7XG4gICAgZWxlbTogY3JlYXRlRWxlbWVudCgnbW9kZXJuaXpyJylcbiAgfTtcblxuICAvLyBDbGVhbiB1cCB0aGlzIGVsZW1lbnRcbiAgTW9kZXJuaXpyLl9xLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIG1vZEVsZW0uZWxlbTtcbiAgfSk7XG5cbiAgXG5cbiAgdmFyIG1TdHlsZSA9IHtcbiAgICBzdHlsZTogbW9kRWxlbS5lbGVtLnN0eWxlXG4gIH07XG5cbiAgLy8ga2lsbCByZWYgZm9yIGdjLCBtdXN0IGhhcHBlbiBiZWZvcmUgbW9kLmVsZW0gaXMgcmVtb3ZlZCwgc28gd2UgdW5zaGlmdCBvbiB0b1xuICAvLyB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlLlxuICBNb2Rlcm5penIuX3EudW5zaGlmdChmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgbVN0eWxlLnN0eWxlO1xuICB9KTtcblxuICBcblxuICAvKipcbiAgICogZ2V0Qm9keSByZXR1cm5zIHRoZSBib2R5IG9mIGEgZG9jdW1lbnQsIG9yIGFuIGVsZW1lbnQgdGhhdCBjYW4gc3RhbmQgaW4gZm9yXG4gICAqIHRoZSBib2R5IGlmIGEgcmVhbCBib2R5IGRvZXMgbm90IGV4aXN0XG4gICAqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gZ2V0Qm9keVxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8U1ZHRWxlbWVudH0gUmV0dXJucyB0aGUgcmVhbCBib2R5IG9mIGEgZG9jdW1lbnQsIG9yIGFuXG4gICAqIGFydGlmaWNpYWxseSBjcmVhdGVkIGVsZW1lbnQgdGhhdCBzdGFuZHMgaW4gZm9yIHRoZSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgIC8vIEFmdGVyIHBhZ2UgbG9hZCBpbmplY3RpbmcgYSBmYWtlIGJvZHkgZG9lc24ndCB3b3JrIHNvIGNoZWNrIGlmIGJvZHkgZXhpc3RzXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKCFib2R5KSB7XG4gICAgICAvLyBDYW4ndCB1c2UgdGhlIHJlYWwgYm9keSBjcmVhdGUgYSBmYWtlIG9uZS5cbiAgICAgIGJvZHkgPSBjcmVhdGVFbGVtZW50KGlzU1ZHID8gJ3N2ZycgOiAnYm9keScpO1xuICAgICAgYm9keS5mYWtlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuXG4gIDtcblxuICAvKipcbiAgICogaW5qZWN0RWxlbWVudFdpdGhTdHlsZXMgaW5qZWN0cyBhbiBlbGVtZW50IHdpdGggc3R5bGUgZWxlbWVudCBhbmQgc29tZSBDU1MgcnVsZXNcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBpbmplY3RFbGVtZW50V2l0aFN0eWxlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIFN0cmluZyByZXByZXNlbnRpbmcgYSBjc3MgcnVsZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHRlc3QgdGhlIGluamVjdGVkIGVsZW1lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtub2Rlc10gLSBBbiBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIGFkZGl0aW9uYWwgbm9kZXMgeW91IHdhbnQgaW5qZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3Rlc3RuYW1lc10gLSBBbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgYXJlIHVzZWQgYXMgaWRzIGZvciB0aGUgYWRkaXRpb25hbCBub2Rlc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIHRlc3RcbiAgICovXG4gIGZ1bmN0aW9uIGluamVjdEVsZW1lbnRXaXRoU3R5bGVzKHJ1bGUsIGNhbGxiYWNrLCBub2RlcywgdGVzdG5hbWVzKSB7XG4gICAgdmFyIG1vZCA9ICdtb2Rlcm5penInO1xuICAgIHZhciBzdHlsZTtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBub2RlO1xuICAgIHZhciBkb2NPdmVyZmxvdztcbiAgICB2YXIgZGl2ID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIGJvZHkgPSBnZXRCb2R5KCk7XG5cbiAgICBpZiAocGFyc2VJbnQobm9kZXMsIDEwKSkge1xuICAgICAgLy8gSW4gb3JkZXIgbm90IHRvIGdpdmUgZmFsc2UgcG9zaXRpdmVzIHdlIGNyZWF0ZSBhIG5vZGUgZm9yIGVhY2ggdGVzdFxuICAgICAgLy8gVGhpcyBhbHNvIGFsbG93cyB0aGUgbWV0aG9kIHRvIHNjYWxlIGZvciB1bnNwZWNpZmllZCB1c2VzXG4gICAgICB3aGlsZSAobm9kZXMtLSkge1xuICAgICAgICBub2RlID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG5vZGUuaWQgPSB0ZXN0bmFtZXMgPyB0ZXN0bmFtZXNbbm9kZXNdIDogbW9kICsgKG5vZGVzICsgMSk7XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdHlsZSA9IGNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgc3R5bGUuaWQgPSAncycgKyBtb2Q7XG5cbiAgICAvLyBJRTYgd2lsbCBmYWxzZSBwb3NpdGl2ZSBvbiBzb21lIHRlc3RzIGR1ZSB0byB0aGUgc3R5bGUgZWxlbWVudCBpbnNpZGUgdGhlIHRlc3QgZGl2IHNvbWVob3cgaW50ZXJmZXJpbmcgb2Zmc2V0SGVpZ2h0LCBzbyBpbnNlcnQgaXQgaW50byBib2R5IG9yIGZha2Vib2R5LlxuICAgIC8vIE9wZXJhIHdpbGwgYWN0IGFsbCBxdWlya3kgd2hlbiBpbmplY3RpbmcgZWxlbWVudHMgaW4gZG9jdW1lbnRFbGVtZW50IHdoZW4gcGFnZSBpcyBzZXJ2ZWQgYXMgeG1sLCBuZWVkcyBmYWtlYm9keSB0b28uICMyNzBcbiAgICAoIWJvZHkuZmFrZSA/IGRpdiA6IGJvZHkpLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICBib2R5LmFwcGVuZENoaWxkKGRpdik7XG5cbiAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcnVsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocnVsZSkpO1xuICAgIH1cbiAgICBkaXYuaWQgPSBtb2Q7XG5cbiAgICBpZiAoYm9keS5mYWtlKSB7XG4gICAgICAvL2F2b2lkIGNyYXNoaW5nIElFOCwgaWYgYmFja2dyb3VuZCBpbWFnZSBpcyB1c2VkXG4gICAgICBib2R5LnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgICAgIC8vU2FmYXJpIDUuMTMvNS4xLjQgT1NYIHN0b3BzIGxvYWRpbmcgaWYgOjotd2Via2l0LXNjcm9sbGJhciBpcyB1c2VkIGFuZCBzY3JvbGxiYXJzIGFyZSB2aXNpYmxlXG4gICAgICBib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICBkb2NPdmVyZmxvdyA9IGRvY0VsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG4gICAgICBkb2NFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICBkb2NFbGVtZW50LmFwcGVuZENoaWxkKGJvZHkpO1xuICAgIH1cblxuICAgIHJldCA9IGNhbGxiYWNrKGRpdiwgcnVsZSk7XG4gICAgLy8gSWYgdGhpcyBpcyBkb25lIGFmdGVyIHBhZ2UgbG9hZCB3ZSBkb24ndCB3YW50IHRvIHJlbW92ZSB0aGUgYm9keSBzbyBjaGVjayBpZiBib2R5IGV4aXN0c1xuICAgIGlmIChib2R5LmZha2UpIHtcbiAgICAgIGJvZHkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib2R5KTtcbiAgICAgIGRvY0VsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBkb2NPdmVyZmxvdztcbiAgICAgIC8vIFRyaWdnZXIgbGF5b3V0IHNvIGtpbmV0aWMgc2Nyb2xsaW5nIGlzbid0IGRpc2FibGVkIGluIGlPUzYrXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGRvY0VsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuICAgIH1cblxuICAgIHJldHVybiAhIXJldDtcbiAgfVxuXG4gIDtcblxuICAvKipcbiAgICogZG9tVG9DU1MgdGFrZXMgYSBjYW1lbENhc2Ugc3RyaW5nIGFuZCBjb252ZXJ0cyBpdCB0byBrZWJhYi1jYXNlXG4gICAqIGUuZy4gYm94U2l6aW5nIC0+IGJveC1zaXppbmdcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBkb21Ub0NTU1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFN0cmluZyBuYW1lIG9mIGNhbWVsQ2FzZSBwcm9wIHdlIHdhbnQgdG8gY29udmVydFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUga2ViYWItY2FzZSB2ZXJzaW9uIG9mIHRoZSBzdXBwbGllZCBuYW1lXG4gICAqL1xuICBmdW5jdGlvbiBkb21Ub0NTUyhuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihzdHIsIG0xKSB7XG4gICAgICByZXR1cm4gJy0nICsgbTEudG9Mb3dlckNhc2UoKTtcbiAgICB9KS5yZXBsYWNlKC9ebXMtLywgJy1tcy0nKTtcbiAgfVxuXG4gIDtcblxuXG4gIC8qKlxuICAgKiB3cmFwcGVyIGFyb3VuZCBnZXRDb21wdXRlZFN0eWxlLCB0byBmaXggaXNzdWVzIHdpdGggRmlyZWZveCByZXR1cm5pbmcgbnVsbCB3aGVuXG4gICAqIGNhbGxlZCBpbnNpZGUgb2YgYSBoaWRkZW4gaWZyYW1lXG4gICAqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gY29tcHV0ZWRTdHlsZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IGVsZW0gLSBUaGUgZWxlbWVudCB3ZSB3YW50IHRvIGZpbmQgdGhlIGNvbXB1dGVkIHN0eWxlcyBvZlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBbcHNldWRvXSAtIEFuIG9wdGlvbmFsIHBzZXVkbyBlbGVtZW50IHNlbGVjdG9yIChlLmcuIDpiZWZvcmUpLCBvZiBudWxsIGlmIG5vbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgLSBBIENTUyBwcm9wZXJ0eVxuICAgKiBAcmV0dXJucyB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgQ1NTIHByb3BlcnR5XG4gICAqL1xuICBmdW5jdGlvbiBjb21wdXRlZFN0eWxlKGVsZW0sIHBzZXVkbywgcHJvcCkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoJ2dldENvbXB1dGVkU3R5bGUnIGluIHdpbmRvdykge1xuICAgICAgcmVzdWx0ID0gZ2V0Q29tcHV0ZWRTdHlsZS5jYWxsKHdpbmRvdywgZWxlbSwgcHNldWRvKTtcbiAgICAgIHZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbnNvbGUpIHtcbiAgICAgICAgICB2YXIgbWV0aG9kID0gY29uc29sZS5lcnJvciA/ICdlcnJvcicgOiAnbG9nJztcbiAgICAgICAgICBjb25zb2xlW21ldGhvZF0uY2FsbChjb25zb2xlLCAnZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5pbmcgbnVsbCwgaXRzIHBvc3NpYmxlIG1vZGVybml6ciB0ZXN0IHJlc3VsdHMgYXJlIGluYWNjdXJhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSAhcHNldWRvICYmIGVsZW0uY3VycmVudFN0eWxlICYmIGVsZW0uY3VycmVudFN0eWxlW3Byb3BdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICA7XG5cbiAgLyoqXG4gICAqIG5hdGl2ZVRlc3RQcm9wcyBhbGxvd3MgZm9yIHVzIHRvIHVzZSBuYXRpdmUgZmVhdHVyZSBkZXRlY3Rpb24gZnVuY3Rpb25hbGl0eSBpZiBhdmFpbGFibGUuXG4gICAqIHNvbWUgcHJlZml4ZWQgZm9ybSwgb3IgZmFsc2UsIGluIHRoZSBjYXNlIG9mIGFuIHVuc3VwcG9ydGVkIHJ1bGVcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBuYXRpdmVUZXN0UHJvcHNcbiAgICogQHBhcmFtIHthcnJheX0gcHJvcHMgLSBBbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIHdlIHdhbnQgdG8gY2hlY2sgdmlhIEBzdXBwb3J0c1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnx1bmRlZmluZWR9IEEgYm9vbGVhbiB3aGVuIEBzdXBwb3J0cyBleGlzdHMsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICovXG4gIC8vIEFjY2VwdHMgYSBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBhIHNpbmdsZSB2YWx1ZVxuICAvLyBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIG5hdGl2ZSBkZXRlY3Rpb24gbm90IGF2YWlsYWJsZVxuICBmdW5jdGlvbiBuYXRpdmVUZXN0UHJvcHMocHJvcHMsIHZhbHVlKSB7XG4gICAgdmFyIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgLy8gU3RhcnQgd2l0aCB0aGUgSlMgQVBJOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzMy1jb25kaXRpb25hbC8jdGhlLWNzcy1pbnRlcmZhY2VcbiAgICBpZiAoJ0NTUycgaW4gd2luZG93ICYmICdzdXBwb3J0cycgaW4gd2luZG93LkNTUykge1xuICAgICAgLy8gVHJ5IGV2ZXJ5IHByZWZpeGVkIHZhcmlhbnQgb2YgdGhlIHByb3BlcnR5XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICh3aW5kb3cuQ1NTLnN1cHBvcnRzKGRvbVRvQ1NTKHByb3BzW2ldKSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlIGZhbGwgYmFjayB0byBhdC1ydWxlIChmb3IgT3BlcmEgMTIueClcbiAgICBlbHNlIGlmICgnQ1NTU3VwcG9ydHNSdWxlJyBpbiB3aW5kb3cpIHtcbiAgICAgIC8vIEJ1aWxkIGEgY29uZGl0aW9uIHN0cmluZyBmb3IgZXZlcnkgcHJlZml4ZWQgdmFyaWFudFxuICAgICAgdmFyIGNvbmRpdGlvblRleHQgPSBbXTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uZGl0aW9uVGV4dC5wdXNoKCcoJyArIGRvbVRvQ1NTKHByb3BzW2ldKSArICc6JyArIHZhbHVlICsgJyknKTtcbiAgICAgIH1cbiAgICAgIGNvbmRpdGlvblRleHQgPSBjb25kaXRpb25UZXh0LmpvaW4oJyBvciAnKTtcbiAgICAgIHJldHVybiBpbmplY3RFbGVtZW50V2l0aFN0eWxlcygnQHN1cHBvcnRzICgnICsgY29uZGl0aW9uVGV4dCArICcpIHsgI21vZGVybml6ciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgfSB9JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICByZXR1cm4gY29tcHV0ZWRTdHlsZShub2RlLCBudWxsLCAncG9zaXRpb24nKSA9PT0gJ2Fic29sdXRlJztcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIDtcblxuICAvKipcbiAgICogY3NzVG9ET00gdGFrZXMgYSBrZWJhYi1jYXNlIHN0cmluZyBhbmQgY29udmVydHMgaXQgdG8gY2FtZWxDYXNlXG4gICAqIGUuZy4gYm94LXNpemluZyAtPiBib3hTaXppbmdcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBjc3NUb0RPTVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFN0cmluZyBuYW1lIG9mIGtlYmFiLWNhc2UgcHJvcCB3ZSB3YW50IHRvIGNvbnZlcnRcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNhbWVsQ2FzZSB2ZXJzaW9uIG9mIHRoZSBzdXBwbGllZCBuYW1lXG4gICAqL1xuICBmdW5jdGlvbiBjc3NUb0RPTShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvKFthLXpdKS0oW2Etel0pL2csIGZ1bmN0aW9uKHN0ciwgbTEsIG0yKSB7XG4gICAgICByZXR1cm4gbTEgKyBtMi50b1VwcGVyQ2FzZSgpO1xuICAgIH0pLnJlcGxhY2UoL14tLywgJycpO1xuICB9XG5cbiAgO1xuXG4gIC8vIHRlc3RQcm9wcyBpcyBhIGdlbmVyaWMgQ1NTIC8gRE9NIHByb3BlcnR5IHRlc3QuXG5cbiAgLy8gSW4gdGVzdGluZyBzdXBwb3J0IGZvciBhIGdpdmVuIENTUyBwcm9wZXJ0eSwgaXQncyBsZWdpdCB0byB0ZXN0OlxuICAvLyAgICBgZWxlbS5zdHlsZVtzdHlsZU5hbWVdICE9PSB1bmRlZmluZWRgXG4gIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQgaXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgc3RyaW5nLFxuICAvLyBpZiB1bnN1cHBvcnRlZCBpdCB3aWxsIHJldHVybiB1bmRlZmluZWQuXG5cbiAgLy8gV2UnbGwgdGFrZSBhZHZhbnRhZ2Ugb2YgdGhpcyBxdWljayB0ZXN0IGFuZCBza2lwIHNldHRpbmcgYSBzdHlsZVxuICAvLyBvbiBvdXIgbW9kZXJuaXpyIGVsZW1lbnQsIGJ1dCBpbnN0ZWFkIGp1c3QgdGVzdGluZyB1bmRlZmluZWQgdnNcbiAgLy8gZW1wdHkgc3RyaW5nLlxuXG4gIC8vIFByb3BlcnR5IG5hbWVzIGNhbiBiZSBwcm92aWRlZCBpbiBlaXRoZXIgY2FtZWxDYXNlIG9yIGtlYmFiLWNhc2UuXG5cbiAgZnVuY3Rpb24gdGVzdFByb3BzKHByb3BzLCBwcmVmaXhlZCwgdmFsdWUsIHNraXBWYWx1ZVRlc3QpIHtcbiAgICBza2lwVmFsdWVUZXN0ID0gaXMoc2tpcFZhbHVlVGVzdCwgJ3VuZGVmaW5lZCcpID8gZmFsc2UgOiBza2lwVmFsdWVUZXN0O1xuXG4gICAgLy8gVHJ5IG5hdGl2ZSBkZXRlY3QgZmlyc3RcbiAgICBpZiAoIWlzKHZhbHVlLCAndW5kZWZpbmVkJykpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuYXRpdmVUZXN0UHJvcHMocHJvcHMsIHZhbHVlKTtcbiAgICAgIGlmICghaXMocmVzdWx0LCAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UgZG8gaXQgcHJvcGVybHlcbiAgICB2YXIgYWZ0ZXJJbml0LCBpLCBwcm9wc0xlbmd0aCwgcHJvcCwgYmVmb3JlO1xuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHN0eWxlIGVsZW1lbnQsIHRoYXQgbWVhbnMgd2UncmUgcnVubmluZyBhc3luYyBvciBhZnRlclxuICAgIC8vIHRoZSBjb3JlIHRlc3RzLCBzbyB3ZSdsbCBuZWVkIHRvIGNyZWF0ZSBvdXIgb3duIGVsZW1lbnRzIHRvIHVzZS5cblxuICAgIC8vIEluc2lkZSBvZiBhbiBTVkcgZWxlbWVudCwgaW4gY2VydGFpbiBicm93c2VycywgdGhlIGBzdHlsZWAgZWxlbWVudCBpcyBvbmx5XG4gICAgLy8gZGVmaW5lZCBmb3IgdmFsaWQgdGFncy4gVGhlcmVmb3JlLCBpZiBgbW9kZXJuaXpyYCBkb2VzIG5vdCBoYXZlIG9uZSwgd2VcbiAgICAvLyBmYWxsIGJhY2sgdG8gYSBsZXNzIHVzZWQgZWxlbWVudCBhbmQgaG9wZSBmb3IgdGhlIGJlc3QuXG4gICAgLy8gRm9yIHN0cmljdCBYSFRNTCBicm93c2VycyB0aGUgaGFyZGx5IHVzZWQgc2FtcCBlbGVtZW50IGlzIHVzZWQuXG4gICAgdmFyIGVsZW1zID0gWydtb2Rlcm5penInLCAndHNwYW4nLCAnc2FtcCddO1xuICAgIHdoaWxlICghbVN0eWxlLnN0eWxlICYmIGVsZW1zLmxlbmd0aCkge1xuICAgICAgYWZ0ZXJJbml0ID0gdHJ1ZTtcbiAgICAgIG1TdHlsZS5tb2RFbGVtID0gY3JlYXRlRWxlbWVudChlbGVtcy5zaGlmdCgpKTtcbiAgICAgIG1TdHlsZS5zdHlsZSA9IG1TdHlsZS5tb2RFbGVtLnN0eWxlO1xuICAgIH1cblxuICAgIC8vIERlbGV0ZSB0aGUgb2JqZWN0cyBpZiB3ZSBjcmVhdGVkIHRoZW0uXG4gICAgZnVuY3Rpb24gY2xlYW5FbGVtcygpIHtcbiAgICAgIGlmIChhZnRlckluaXQpIHtcbiAgICAgICAgZGVsZXRlIG1TdHlsZS5zdHlsZTtcbiAgICAgICAgZGVsZXRlIG1TdHlsZS5tb2RFbGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wc0xlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICBiZWZvcmUgPSBtU3R5bGUuc3R5bGVbcHJvcF07XG5cbiAgICAgIGlmIChjb250YWlucyhwcm9wLCAnLScpKSB7XG4gICAgICAgIHByb3AgPSBjc3NUb0RPTShwcm9wKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1TdHlsZS5zdHlsZVtwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgLy8gSWYgdmFsdWUgdG8gdGVzdCBoYXMgYmVlbiBwYXNzZWQgaW4sIGRvIGEgc2V0LWFuZC1jaGVjayB0ZXN0LlxuICAgICAgICAvLyAwIChpbnRlZ2VyKSBpcyBhIHZhbGlkIHByb3BlcnR5IHZhbHVlLCBzbyBjaGVjayB0aGF0IGB2YWx1ZWAgaXNuJ3RcbiAgICAgICAgLy8gdW5kZWZpbmVkLCByYXRoZXIgdGhhbiBqdXN0IGNoZWNraW5nIGl0J3MgdHJ1dGh5LlxuICAgICAgICBpZiAoIXNraXBWYWx1ZVRlc3QgJiYgIWlzKHZhbHVlLCAndW5kZWZpbmVkJykpIHtcblxuICAgICAgICAgIC8vIE5lZWRzIGEgdHJ5IGNhdGNoIGJsb2NrIGJlY2F1c2Ugb2Ygb2xkIElFLiBUaGlzIGlzIHNsb3csIGJ1dCB3aWxsXG4gICAgICAgICAgLy8gYmUgYXZvaWRlZCBpbiBtb3N0IGNhc2VzIGJlY2F1c2UgYHNraXBWYWx1ZVRlc3RgIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbVN0eWxlLnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSB2YWx1ZSBoYXMgY2hhbmdlZCwgd2UgYXNzdW1lIHRoZSB2YWx1ZSB1c2VkIGlzXG4gICAgICAgICAgLy8gc3VwcG9ydGVkLiBJZiBgdmFsdWVgIGlzIGVtcHR5IHN0cmluZywgaXQnbGwgZmFpbCBoZXJlIChiZWNhdXNlXG4gICAgICAgICAgLy8gaXQgaGFzbid0IGNoYW5nZWQpLCB3aGljaCBtYXRjaGVzIGhvdyBicm93c2VycyBoYXZlIGltcGxlbWVudGVkXG4gICAgICAgICAgLy8gQ1NTLnN1cHBvcnRzKClcbiAgICAgICAgICBpZiAobVN0eWxlLnN0eWxlW3Byb3BdICE9PSBiZWZvcmUpIHtcbiAgICAgICAgICAgIGNsZWFuRWxlbXMoKTtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXhlZCA9PT0gJ3BmeCcgPyBwcm9wIDogdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRydWUsIG9yIHRoZSBwcm9wZXJ0eSBuYW1lIGlmIHRoaXMgaXMgYVxuICAgICAgICAvLyBgcHJlZml4ZWQoKWAgY2FsbFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjbGVhbkVsZW1zKCk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeGVkID09PSAncGZ4JyA/IHByb3AgOiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNsZWFuRWxlbXMoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICA7XG5cbiAgLyoqXG4gICAqIHRlc3RQcm9wKCkgaW52ZXN0aWdhdGVzIHdoZXRoZXIgYSBnaXZlbiBzdHlsZSBwcm9wZXJ0eSBpcyByZWNvZ25pemVkXG4gICAqIFByb3BlcnR5IG5hbWVzIGNhbiBiZSBwcm92aWRlZCBpbiBlaXRoZXIgY2FtZWxDYXNlIG9yIGtlYmFiLWNhc2UuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBNb2Rlcm5penJcbiAgICogQG5hbWUgTW9kZXJuaXpyLnRlc3RQcm9wXG4gICAqIEBhY2Nlc3MgcHVibGljXG4gICAqIEBvcHRpb25OYW1lIE1vZGVybml6ci50ZXN0UHJvcCgpXG4gICAqIEBvcHRpb25Qcm9wIHRlc3RQcm9wXG4gICAqIEBmdW5jdGlvbiB0ZXN0UHJvcFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCAtIE5hbWUgb2YgdGhlIENTUyBwcm9wZXJ0eSB0byBjaGVja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSAtIE5hbWUgb2YgdGhlIENTUyB2YWx1ZSB0byBjaGVja1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VWYWx1ZV0gLSBXaGV0aGVyIG9yIG5vdCB0byBjaGVjayB0aGUgdmFsdWUgaWYgQHN1cHBvcnRzIGlzbid0IHN1cHBvcnRlZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQsIHVuZGVmaW5lZCBpZiBpdHMgdW5zdXBwb3J0ZWRcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogSnVzdCBsaWtlIFt0ZXN0QWxsUHJvcHNdKCNtb2Rlcm5penItdGVzdGFsbHByb3BzKSwgb25seSBpdCBkb2VzIG5vdCBjaGVjayBhbnkgdmVuZG9yIHByZWZpeGVkXG4gICAqIHZlcnNpb24gb2YgdGhlIHN0cmluZy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBwcm9wZXJ0eSBuYW1lIG11c3QgYmUgcHJvdmlkZWQgaW4gY2FtZWxDYXNlIChlLmcuIGJveFNpemluZyBub3QgYm94LXNpemluZylcbiAgICpcbiAgICogYGBganNcbiAgICogTW9kZXJuaXpyLnRlc3RQcm9wKCdwb2ludGVyRXZlbnRzJykgIC8vIHRydWVcbiAgICogYGBgXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgdmFsdWUgYXMgYW4gb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGNoZWNrIGlmIGFcbiAgICogc3BlY2lmaWMgdmFsdWUgaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIE1vZGVybml6ci50ZXN0UHJvcCgncG9pbnRlckV2ZW50cycsICdub25lJykgLy8gdHJ1ZVxuICAgKiBNb2Rlcm5penIudGVzdFByb3AoJ3BvaW50ZXJFdmVudHMnLCAncGVuZ3VpbicpIC8vIGZhbHNlXG4gICAqIGBgYFxuICAgKi9cbiAgdmFyIHRlc3RQcm9wID0gTW9kZXJuaXpyUHJvdG8udGVzdFByb3AgPSBmdW5jdGlvbihwcm9wLCB2YWx1ZSwgdXNlVmFsdWUpIHtcbiAgICByZXR1cm4gdGVzdFByb3BzKFtwcm9wXSwgdW5kZWZpbmVkLCB2YWx1ZSwgdXNlVmFsdWUpO1xuICB9O1xuXG4gIFxuXG4gIC8vIFJ1biBlYWNoIHRlc3RcbiAgdGVzdFJ1bm5lcigpO1xuXG4gIC8vIFJlbW92ZSB0aGUgXCJuby1qc1wiIGNsYXNzIGlmIGl0IGV4aXN0c1xuICBzZXRDbGFzc2VzKGNsYXNzZXMpO1xuXG4gIGRlbGV0ZSBNb2Rlcm5penJQcm90by5hZGRUZXN0O1xuICBkZWxldGUgTW9kZXJuaXpyUHJvdG8uYWRkQXN5bmNUZXN0O1xuXG4gIC8vIFJ1biB0aGUgdGhpbmdzIHRoYXQgYXJlIHN1cHBvc2VkIHRvIHJ1biBhZnRlciB0aGUgdGVzdHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNb2Rlcm5penIuX3EubGVuZ3RoOyBpKyspIHtcbiAgICBNb2Rlcm5penIuX3FbaV0oKTtcbiAgfVxuXG4gIC8vIExlYWsgTW9kZXJuaXpyIG5hbWVzcGFjZVxuICB3aW5kb3cuTW9kZXJuaXpyID0gTW9kZXJuaXpyO1xuXG5cbjtcblxufSkod2luZG93LCBkb2N1bWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gd2luZG93Lk1vZGVybml6cjtcbmlmIChoYWRHbG9iYWwpIHsgd2luZG93Lk1vZGVybml6ciA9IG9sZEdsb2JhbDsgfVxuZWxzZSB7IGRlbGV0ZSB3aW5kb3cuTW9kZXJuaXpyOyB9XG59KSh3aW5kb3cpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.modernizrrc.js\n");

/***/ }),

/***/ "./assets/js/modernizr.js":
/*!********************************!*\
  !*** ./assets/js/modernizr.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var modernizr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modernizr */ \"./.modernizrrc.js\");\n/* harmony import */ var modernizr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(modernizr__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Fix for touchevents on Chrome Desktop - Modernizr 3.7.1\n * https://github.com/Modernizr/Modernizr/issues/2431\n */\n\nmodernizr__WEBPACK_IMPORTED_MODULE_0___default.a.addTest('touchevents', function () {\n  if ('ontouchstart' in window) {\n    return true;\n  }\n\n  return false;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbW9kZXJuaXpyLmpzP2RjNTYiXSwibmFtZXMiOlsiTW9kZXJuaXpyIiwiYWRkVGVzdCIsIndpbmRvdyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7Ozs7QUFJQUEsZ0RBQVMsQ0FBQ0MsT0FBVixDQUFrQixhQUFsQixFQUFpQyxZQUFXO0FBQzFDLE1BQUksa0JBQWtCQyxNQUF0QixFQUE4QjtBQUM1QixXQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFPLEtBQVA7QUFDRCxDQU5EIiwiZmlsZSI6Ii4vYXNzZXRzL2pzL21vZGVybml6ci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNb2Rlcm5penIgZnJvbSAnbW9kZXJuaXpyJztcblxuLyoqXG4gKiBGaXggZm9yIHRvdWNoZXZlbnRzIG9uIENocm9tZSBEZXNrdG9wIC0gTW9kZXJuaXpyIDMuNy4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9pc3N1ZXMvMjQzMVxuICovXG5Nb2Rlcm5penIuYWRkVGVzdCgndG91Y2hldmVudHMnLCBmdW5jdGlvbigpIHtcbiAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/js/modernizr.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ 3:
/*!**************************************!*\
  !*** multi ./assets/js/modernizr.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/harry/Work/Tincan/_DEFAULTS/Pippip/assets/js/modernizr.js */"./assets/js/modernizr.js");


/***/ })

/******/ });